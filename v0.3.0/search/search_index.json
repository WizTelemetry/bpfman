{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>bpfd is a system daemon aimed at simplifying the deployment and management of eBPF programs. It's goal is to enhance the developer-experience as well as provide features to improve security, visibility and program-cooperation. bpfd includes a Kubernetes operator to bring those same features to Kubernetes, allowing users to safely deploy eBPF via custom resources across nodes in a cluster.</p>"},{"location":"#why-ebpf","title":"Why eBPF?","text":"<p>eBPF is a powerful general-purpose framework that allows running sandboxed programs in the kernel.  It can be used for many purposes, including networking, monitoring, tracing and security.</p>"},{"location":"#why-ebpf-in-kubernetes","title":"Why eBPF in Kubernetes?","text":"<p>Demand is increasing from both Kubernetes developers and users. Examples of eBPF in Kubernetes include:</p> <ul> <li>Cilium and Calico   CNIs</li> <li>Pixie: Open source observability</li> <li>KubeArmor: Container-aware runtime security   enforcement system</li> <li>Blixt: Gateway API L4 conformance   implementation</li> <li>NetObserv: Open source operator for network   observability</li> </ul>"},{"location":"#challenges-for-ebpf-in-kubernetes","title":"Challenges for eBPF in Kubernetes","text":"<ul> <li>Requires privileged pods.</li> <li>eBPF-enabled apps require at least CAP_BPF permissions and potentially       more depending on the type of program that is being attached.</li> <li>Since the Linux capabilities are very broad it is challenging to constrain       a pod to the minimum set of privileges required. This can allow them to do       damage (either unintentionally or intentionally).</li> <li>Handling multiple eBPF programs on the same eBPF hooks.</li> <li>Not all eBPF hooks are designed to support multiple programs.</li> <li>Some software using eBPF assumes exclusive use of an eBPF hook and can       unintentionally eject existing programs when being attached. This can       result in silent failures and non-deterministic failures.</li> <li>Debugging problems with deployments is hard.</li> <li>The cluster administrator may not be aware that eBPF programs are being       used in a cluster.</li> <li>It is possible for some eBPF programs to interfere with others in       unpredictable ways.</li> <li>SSH access or a privileged pod is necessary to determine the state of eBPF       programs on each node in the cluster.</li> <li>Lifecycle management of eBPF programs.</li> <li>While there are libraries for the basic loading and unloading of eBPF       programs, a lot of code is often needed around them for lifecycle       management.</li> <li>Deployment on Kubernetes is not simple.</li> <li>It is an involved process that requires first writing a daemon that loads       your eBPF bytecode and deploying it using a DaemonSet.</li> <li>This requires careful design and intricate knowledge of the eBPF program       lifecycle to ensure your program stays loaded and that you can easily       tolerate pod restarts and upgrades.</li> <li>In eBPF enabled K8s deployments today, the eBPF Program is often embedded       into the userspace binary that loads and interacts with it. This means       there's no easy way to have fine-grained versioning control of the       bpfProgram in relation to it's accompanying userspace counterpart.</li> </ul>"},{"location":"#what-is-bpfd","title":"What is bpfd?","text":"<p>bpfd is a software stack that aims to make it easy to load, unload, modify and monitor eBPF programs whether on a single host, or in a Kubernetes cluster. bpfd includes the following core components:</p> <ul> <li>bpfd: A system daemon that supports loading, unloading, modifying and   monitoring of eBPF programs exposed over a gRPC API.</li> <li>eBPF CRDS: bpfd provides a set of CRDs (<code>XdpProgram</code>, <code>TcProgram</code>, etc.) that   provide a way to express intent to load eBPF programs as well as a bpfd   generated CRD (<code>BpfProgram</code>) used to represent the runtime state of loaded   programs.</li> <li>bpfd-agent: The agent runs in a container in the bpfd daemonset and ensures   that the requested eBPF programs for a given node are in the desired state.</li> <li>bpfd-operator: An operator, built using Operator   SDK, that manages the installation and   lifecycle of bpfd-agent and the CRDs in a Kubernetes cluster.</li> </ul> <p>bpfd is developed in Rust and built on top of Aya, a Rust eBPF library.</p> <p>The benefits of this solution include the following:</p> <ul> <li>Security</li> <li>Improved security because only the bpfd daemon, which can be tightly       controlled, has the privileges needed to load eBPF programs, while access       to the API can be controlled via standard RBAC methods.  Within bpfd, only       a single thread keeps these capabilities while the other threads (serving       RPCs) do not.</li> <li>Gives the administrators control over who can load programs.</li> <li>Allows administrators to define rules for the ordering of networking eBPF       programs. (ROADMAP)</li> <li>Visibility/Debuggability</li> <li>Improved visibility into what eBPF programs are running on a system, which       enhances the debuggability for developers, administrators, and customer       support.</li> <li>The greatest benefit is achieved when all apps use bpfd, but even if they       don't, bpfd can provide visibility into all the eBPF programs loaded on       the nodes in a cluster.</li> <li>Multi-program Support</li> <li>Support for the coexistence of multiple eBPF programs from multiple users.</li> <li>Uses the libxdp multiprog       protocol       to allow multiple XDP programs on single interface</li> <li>This same protocol is also supported for TC programs to provide a common       multi-program user experience across both TC and XDP.</li> <li>Productivity</li> <li>Simplifies the deployment and lifecycle management of eBPF programs in a       Kubernetes cluster.</li> <li>developers can stop worrying about program lifecycle (loading, attaching,       pin management, etc.) and use existing eBPF libraries to interact with       their program maps using well defined pin points which are managed by       bpfd.</li> <li>Developers can still use Cilium/libbpf/Aya/etc libraries for eBPF       development, and load/unload with bpfd.</li> <li>Provides eBPF Bytecode Image Specifications that allows fine-grained       separate versioning control for userspace and kernelspace programs. This       also allows for signing these container images to verify bytecode       ownership.</li> </ul> <p>For more details, please see the following:</p> <ul> <li>Setup and Building bpfd for instructions   on setting up your development environment and building bpfd.</li> <li>Tutorial for some examples of starting   <code>bpfd</code>, managing logs, and using <code>bpfctl</code>.</li> <li>Example eBPF Programs for some examples of   eBPF programs written in Go, interacting with <code>bpfd</code>.</li> <li>Deploying the bpfd-operator for   details on launching bpfd in a Kubernetes cluster.</li> <li>Meet the Community for details on community   meeting details.</li> </ul>"},{"location":"blog/","title":"Bpfd Blog","text":""},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/","title":"bpfd: A Novel Way to Manage eBPF","text":"<p>In today's cloud ecosystem, there's a demand for low-level system access to enable high-performance observability, security, and networking functionality for applications. Historically these features have been implemented in user space, however, the ability to program such functionality into the kernel itself can provide many benefits including (but not limited to) performance. Regardless, many Linux users still opt away from in-tree or kernel module development due to the slow rate of iteration and ensuing large management burden.  eBPF has emerged as a technology in the Linux Kernel looking to change all that.</p> <p>eBPF is a simple and efficient way to dynamically load programs into the kernel at runtime, with safety and performance provided by the kernel itself using a Just-In-Time (JIT) compiler and verification process. There are a wide variety of program types one can create with eBPF, which include everything from networking applications to security systems.</p> <p>However, eBPF is still a fairly nascent technology and it's not all kittens and rainbows. The process of developing, testing, deploying, and maintaining eBPF programs is not a road well traveled yet, and the story gets even more complicated when you want to deploy your programs in a multi-node system, such as a Kubernetes cluster. It was these kinds of problems that motivated the creation of bpfd, a system daemon for loading and managing eBPF programs in both traditional systems and Kubernetes clusters. In this blog post, we'll discuss the problems bpfd can help solve, and how to deploy and use it.</p>"},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/#current-challenges-with-developing-and-deploying-ebpf-programs","title":"Current Challenges with Developing and Deploying eBPF Programs","text":"<p>While some organizations have had success developing, deploying, and maintaining production software which includes eBPF programs, the barrier to entry is still very high. </p> <p>Following the basic eBPF development workflow, which often involves many hours trying to interpret and fix mind-bending eBPF verifier errors, the process of deploying a program in testing and staging environments often results in a lot of custom program loading and management functionality specific to the application. When moving to production systems in environments like Kubernetes clusters the operational considerations continue to compound.</p> <p>Security is another significant challenge, which we will cover in more depth in a follow-on blog.  However, at a high level, applications that use eBPF typically load their own eBPF programs, which requires at least CAP_BPF.  Many BPF programs and attach points require additional capabilities from CAP_SYS_PTRACE, CAP_NET_ADMIN and even including CAP_SYS_ADMIN.  These privileges include capabilities that aren\u2019t strictly necessary for eBPF and are too coarsely grained to be useful.  Since the processes that load eBPF are usually long-lived and often don\u2019t drop privileges it leaves a wide attack surface.</p> <p>While it doesn't solve all the ergonomic and maintenance problems associated with adopting eBPF, bpfd does try to address several of these issues -- particularly as it pertains to security and the lifecycle management of eBPF programs. In the coming sections, we will go into more depth about what eBPF does, and how it can help reduce the costs associated with deploying and managing eBPF-powered workloads.</p>"},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/#bpfd-overview","title":"bpfd Overview","text":"<p>The bpfd project provides a software stack that makes it easy to manage the full lifecycle of eBPF programs.  In particular, it can load, unload, modify, and monitor eBPF programs on a single host, or across a full Kubernetes cluster. The key components of bpfd include the bpfd daemon itself which can run independently on any Linux box, an accompanying Kubernetes Operator designed to bring first-class support to clusters via Custom Resource Definitions (CRDs),  and eBPF program packaging.</p> <p>These components will be covered in more detail in the following sections.</p>"},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/#bpfd-daemon","title":"bpfd Daemon","text":"<p>The bpfd daemon works directly with the operating system to manage eBPF programs.  It loads, updates, and unloads eBPF programs, pins maps, and provides visibility into the eBPF programs loaded on a system.  Currently, bpfd fully supports XDP, TC, Tracepoint, uProbe, and kProbe eBPF programs. In addition, bpfd can display information about all types of eBPF programs loaded on a system whether they were loaded by bpfd or some other mechanism. bpfd is developed in the Rust programming language and uses Aya, an eBPF library which is also developed in Rust.</p> <p>When used on an individual server, bpfd runs as a system daemon, and applications communicate with it using a gRPC API.  bpfd can also be used via a command line tool called bpfctl which in turn uses the gRPC API. The following is an example of using bpfctl to load and attach an xdp program.</p> <pre><code>bpfctl load-from-image -g GLOBAL_u8=01 -i quay.io/bpfd-bytecode/xdp_pass:latest xdp -i eth0 -p 100\n</code></pre> <p>This architecture is depicted in the following diagram.</p> <p></p> <p>Using bpfd in this manner significantly improves security because the API is secured using mTLS, and only bpfd needs the privileges required to load and manage eBPF programs and maps.</p> <p>Writing eBPF code is tough enough as it is.  Typically, an eBPF-based application would need to also implement support for the lifecycle management of the required eBPF programs.  bpfd does that for you and allows you to focus on developing your application.</p> <p>Another key functional advantage that bpfd offers over libbpf or the Cilium ebpf-go library is support for multiple XDP programs. Standard XDP only allows a single XDP program on a given interface, while bpfd supports loading multiple XDP programs on each interface using the multi-prog protocol defined in libxdp. This allows the user to add, delete, update, prioritize, and re-prioritize the multiple programs on each interface. There is also support to configure whether the flow of execution should terminate and return or continue to the next program in the list based on the return value.</p> <p>While TC natively supports multiple programs on each attach point, it lacks the controls and flexibility enabled by the multi-prog protocol. bpfd therefore also supports the same XDP multi-prog solution for TC programs which has the added benefit of a consistent user experience for both XDP and TC programs.</p> <p>eBPF programs are also difficult to debug on a system.  The visibility provided by bpfd can be a key tool in understanding what is deployed and how they may interact.</p>"},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/#bpfd-kubernetes-support","title":"bpfd Kubernetes Support","text":"<p>The benefits of bpfd are brought to Kubernetes by the bpfd operator.  The bpfd operator is developed in Go using the Operator SDK framework, so it should be familiar to most Kubernetes application developers. The bpfd operator deploys a daemonset, containing both bpfd and the bpfd agent processes on each node. Rather than making requests directly to bpfd with the gRPC API or bpfctl as described above, Kubernetes applications use bpfd custom resource definitions (CRDs) to make requests to bpfd to load and attach eBPF programs.  bpfd uses two types of CRDs; Program CRDs for each eBPF program type (referred to as *Program CRDs, where * = Xdp, Tc, etc.) created by the application to express the desired state of an eBPF program on the cluster, and per node BpfProgram CRDs created by the bpfd agent to report the current state of the eBPF program on each node.</p> <p>Using XDP as an example, the application can request that an XDP program be loaded on multiple nodes using the XdpProgram CRD, which includes the necessary information such as the bytecode image to load, interface to attach it to, and priority.  An XdpProgram CRD that would do the same thing as the bpfctl command shown above on every node in a cluster is shown below.</p> <pre><code>apiVersion: bpfd.dev/v1alpha1\nkind: XdpProgram\nmetadata:\nlabels:\napp.kubernetes.io/name: xdpprogram\nname: xdp-pass-all-nodes\nspec:\nname: pass\n# Select all nodes\nnodeselector: {}\ninterfaceselector:\nprimarynodeinterface: true\npriority: 0\nbytecode:\nimage:\nurl: quay.io/bpfd-bytecode/xdp_pass:latest\nglobaldata:\nGLOBAL_u8:\n- 0x01\n</code></pre> <p>The bpfd agent on each node watches for the *Program CRDs, and makes calls to the local instance of bpfd as necessary to ensure that the state on the local node reflects the state requested in the *Program CRD.  The bpfd agent on each node in turn creates and updates a BpfProgram object for the *Program CRD that reflects the state of the program on that node and reports the eBPF map information for the program.  The following is the BpfProgram CRD on one node for the above XdpProgram CRD.</p> <pre><code>kubectl get bpfprograms.bpfd.dev xdp-pass-all-nodes-bpfd-deployment-control-plane-eth0 -o yaml\n</code></pre> <pre><code>apiVersion: bpfd.dev/v1alpha1\nkind: BpfProgram\nmetadata:\nannotations:\nbpfd.dev.xdpprogramcontroller/interface: eth0\ncreationTimestamp: \"2023-08-29T22:08:12Z\"\nfinalizers:\n- bpfd.dev.xdpprogramcontroller/finalizer\ngeneration: 1\nlabels:\nbpfd.dev/ownedByProgram: xdp-pass-all-nodes\nkubernetes.io/hostname: bpfd-deployment-control-plane\nname: xdp-pass-all-nodes-bpfd-deployment-control-plane-eth0\nownerReferences:\n- apiVersion: bpfd.dev/v1alpha1\nblockOwnerDeletion: true\ncontroller: true\nkind: XdpProgram\nname: xdp-pass-all-nodes\nuid: 838dc2f8-a348-427e-9dc4-f6a6ea621930\nresourceVersion: \"2690\"\nuid: 5a622961-e5b0-44fe-98af-30756b2d0b62\nspec:\ntype: xdp\nstatus:\nconditions:\n- lastTransitionTime: \"2023-08-29T22:08:14Z\"\nmessage: Successfully loaded bpfProgram\nreason: bpfdLoaded\nstatus: \"True\"\ntype: Loaded\n</code></pre> <p>Finally, the bpfd operator watches for updates to the BpfProgram objects and reports the global state of each eBPF program.  If the program was successfully loaded on every selected node, it will report success, otherwise, it will identify the node(s) that had a problem.  The following is the XdpProgram CRD as updated by the operator.</p> <pre><code>kubectl get xdpprograms.bpfd.dev xdp-pass-all-nodes -o yaml\n</code></pre> <p><pre><code>apiVersion: bpfd.dev/v1alpha1\nkind: XdpProgram\nmetadata:\nannotations:\nkubectl.kubernetes.io/last-applied-configuration: |\n{\"apiVersion\":\"bpfd.dev/v1alpha1\",\"kind\":\"XdpProgram\",\"metadata\":{\"annotations\":{},\"labels\":{\"app.kubernetes.io/name\":\"xdpprogram\"},\"name\":\"xdp-pass-all-nodes\"},\"spec\":{\"bytecode\":{\"image\":{\"url\":\"quay.io/bpfd-bytecode/xdp_pass:latest\"}},\"globaldata\":{\"GLOBAL_u8\":[1]},\"interfaceselector\":{\"primarynodeinterface\":true},\"nodeselector\":{},\"priority\":0,\"bpffunctionname\":\"pass\"}}\ncreationTimestamp: \"2023-08-29T22:08:12Z\"\nfinalizers:\n- bpfd.dev.operator/finalizer\ngeneration: 2\nlabels:\napp.kubernetes.io/name: xdpprogram\nname: xdp-pass-all-nodes\nresourceVersion: \"2685\"\nuid: 838dc2f8-a348-427e-9dc4-f6a6ea621930\nspec:\nbytecode:\nimage:\nimagepullpolicy: IfNotPresent\nurl: quay.io/bpfd-bytecode/xdp_pass:latest\nglobaldata:\nGLOBAL_u8: 0x01\ninterfaceselector:\nprimarynodeinterface: true\nmapownerselector: {}\nnodeselector: {}\npriority: 0\nproceedon:\n- pass\n- dispatcher_return\nname: pass\nstatus:\nconditions:\n- lastTransitionTime: \"2023-08-29T22:08:12Z\"\nmessage: Waiting for Program Object to be reconciled to all nodes\nreason: ProgramsNotYetLoaded\nstatus: \"True\"\ntype: NotYetLoaded\n- lastTransitionTime: \"2023-08-29T22:08:12Z\"\nmessage: bpfProgramReconciliation Succeeded on all nodes\nreason: ReconcileSuccess\nstatus: \"True\"\ntype: ReconcileSuccess\n</code></pre> More details about this process can be seen here</p>"},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/#ebpf-program-packaging","title":"eBPF program packaging","text":"<p>The eBPF Bytecode Image specification was created as part of the bpfd project to define a way to package eBPF bytecode as OCI container images.  Its use was illustrated in the <code>bpfctl</code> and <code>XdpProgram</code> CRD examples above in which the XDP program was loaded from <code>quay.io/bpfd-bytecode/xdp_pass:latest</code>. The initial motivation for this image spec was to facilitate the deployment of eBPF programs in container orchestration systems such as Kubernetes, where it is necessary to provide a portable way to distribute bytecode to all nodes that need it. However, bytecode images have proven useful on standalone Linux systems as well.  When coupled with BPF CO-RE (Compile Once \u2013 Run Everywhere), portability is further enhanced in that applications can use the same bytecode images across different kernel versions without the need to recompile them for each version. Another benefit of bytecode containers is image signing.  There is currently no way to sign and validate raw eBPF bytecode.  However, the bytecode containers can be signed and validated by bpfd using sigstore to improve supply chain security.</p>"},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/#key-benefits-of-bpfd","title":"Key benefits of bpfd","text":"<p>This section reviews some of the key benefits of bpfd.  These benefits mostly apply to both standalone and Kubernetes deployments, but we will focus on the benefits for Kubernetes here.</p>"},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/#security","title":"Security","text":"<p>Probably the most compelling benefit of using bpfd is enhanced security. When using bpfd, only the bpfd daemon, which can be tightly controlled, needs the privileges required to load eBPF programs, while access to the API can be controlled via standard RBAC methods on a per-application and per-CRD basis. Additionally, the signing and validating of bytecode images enables supply chain security. </p>"},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/#visibility-and-debuggability","title":"Visibility and Debuggability","text":"<p>eBPF programs can interact with each other in unexpected ways.  The multi-program support described above helps control these interactions by providing a common mechanism to prioritize and control the flow between the programs.  However, there can still be problems, and there may be eBPF programs running on nodes that were loaded by other mechanisms that you don\u2019t even know about.  bpfd helps here too by reporting all of the eBPF programs running on all of the nodes in a Kubernetes cluster.</p>"},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/#productivity","title":"Productivity","text":"<p>As described above, managing the lifecycle of eBPF programs is something that each application currently needs to do on its own.  It is even more complicated to manage the lifecycle of eBPF programs across a Kubernetes cluster.  bpfd does this for you so you don't have to.  eBPF bytecode images help here as well by simplifying the distribution of eBPF bytecode to multiple nodes in a cluster, and also allowing separate fine-grained versioning control for user space and kernel space code.</p>"},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/#demonstration","title":"Demonstration","text":"<p>This demonstration is adapted from the instructions documented by Andrew Stoycos here.</p> <p>These instructions use kind and bpfd release v0.2.1. It should also be possible to run this demo on other environments such as minikube or an actual cluster.</p> <p>Another option is to build the code yourself and use <code>make run-on-kind</code> to create the cluster as is described in the given links.  Then, start with step 5.</p>"},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/#run-the-demo","title":"Run the demo","text":"<p>1. Create Kind Cluster</p> <pre><code>kind create cluster --name=test-bpfd\n</code></pre> <p>2. Deploy Cert manager</p> <pre><code>kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.11.0/cert-manager.yaml\n</code></pre> <p>3. Deploy bpfd Crds</p> <pre><code>kubectl apply -f  https://github.com/bpfd-dev/bpfd/releases/download/v0.2.1/bpfd-crds-install-v0.2.1.yaml\n</code></pre> <p>4. Deploy bpfd-operator</p> <pre><code>kubectl apply -f https://github.com/bpfd-dev/bpfd/releases/download/v0.2.1/bpfd-operator-install-v0.2.1.yaml\n</code></pre> <p>5. Verify the deployment</p> <pre><code>kubectl get pods -A\n</code></pre> <pre><code>NAMESPACE            NAME                                              READY   STATUS    RESTARTS   AGE\nbpfd                 bpfd-daemon-nkzpf                                 2/2     Running   0          28s\nbpfd                 bpfd-operator-77d697fdd4-clrf7                    2/2     Running   0          33s\ncert-manager         cert-manager-99bb69456-x8n84                      1/1     Running   0          57s\ncert-manager         cert-manager-cainjector-ffb4747bb-pt4hr           1/1     Running   0          57s\ncert-manager         cert-manager-webhook-545bd5d7d8-z5brw             1/1     Running   0          57s\nkube-system          coredns-565d847f94-gjjft                          1/1     Running   0          61s\nkube-system          coredns-565d847f94-mf2cq                          1/1     Running   0          61s\nkube-system          etcd-test-bpfd-control-plane                      1/1     Running   0          76s\nkube-system          kindnet-lv6f9                                     1/1     Running   0          61s\nkube-system          kube-apiserver-test-bpfd-control-plane            1/1     Running   0          76s\nkube-system          kube-controller-manager-test-bpfd-control-plane   1/1     Running   0          77s\nkube-system          kube-proxy-dtmvb                                  1/1     Running   0          61s\nkube-system          kube-scheduler-test-bpfd-control-plane            1/1     Running   0          78s\nlocal-path-storage   local-path-provisioner-684f458cdd-8gxxv           1/1     Running   0          61s\n</code></pre> <p>Note that we have the bpfd-operator, bpf-daemon and cert-manager pods running.</p> <p>6. Deploy the XDP counter program and user space application</p> <pre><code>kubectl apply -f https://github.com/bpfd-dev/bpfd/releases/download/v0.2.1/go-xdp-counter-install-v0.2.1.yaml\n</code></pre> <p>7. Confirm that the programs are loaded</p> <p>Userspace program:</p> <pre><code>kubectl get pods -n go-xdp-counter\n</code></pre> <pre><code>NAME                      READY   STATUS              RESTARTS   AGE\ngo-xdp-counter-ds-9lpgp   0/1     ContainerCreating   0          5s\n</code></pre> <p>XDP program:</p> <pre><code>kubectl get xdpprograms.bpfd.dev -o wide\n</code></pre> <pre><code>NAME                     BPFFUNCTIONNAME   NODESELECTOR   PRIORITY   INTERFACESELECTOR               PROCEEDON\ngo-xdp-counter-example   stats             {}             55         {\"primarynodeinterface\":true}   [\"pass\",\"dispatcher_return\"]\n</code></pre> <p>8. Confirm that the counter program is counting packets.</p> <p>Notes:</p> <ul> <li>The counters are updated every 5 seconds, and stats are being collected for the pod's primary node interface, which may not have a lot of traffic. However, running the <code>kubectl</code> command below generates traffic on that interface, so run the command a few times and give it a few seconds in between to confirm whether the counters are incrementing. </li> <li>Replace \"go-xdp-counter-ds-9lpgp\" with the go-xdp-counter pod name for your deployment.</li> </ul> <pre><code>kubectl logs go-xdp-counter-ds-9lpgp -n go-xdp-counter | tail\n</code></pre> <pre><code>2023/09/05 16:58:21 1204 packets received\n2023/09/05 16:58:21 13741238 bytes received\n\n2023/09/05 16:58:24 1220 packets received\n2023/09/05 16:58:24 13744258 bytes received\n\n2023/09/05 16:58:27 1253 packets received\n2023/09/05 16:58:27 13750364 bytes received\n</code></pre> <p>9. Deploy the <code>xdp-pass-all-nodes</code> program with <code>priority</code> set to 50 and   <code>proceedon</code> set to <code>drop</code> as shown below</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: bpfd.io/v1alpha1\nkind: XdpProgram\nmetadata:\nlabels:\napp.kubernetes.io/name: xdpprogram\nname: xdp-pass-all-nodes\nspec:\nname: pass\nnodeselector: {}\ninterfaceselector:\nprimarynodeinterface: true\npriority: 50\nproceedon:\n- drop\nbytecode:\nimage:\nurl: quay.io/bpfd-bytecode/xdp_pass:latest\nEOF\n</code></pre> <p>10. Verify both XDP programs are loaded.</p> <pre><code>kubectl get xdpprograms.bpfd.io -o wide\n</code></pre> <pre><code>NAME                     BPFFUNCTIONNAME   NODESELECTOR   PRIORITY   INTERFACESELECTOR               PROCEEDON\ngo-xdp-counter-example   stats             {}             55         {\"primarynodeinterface\":true}   [\"pass\",\"dispatcher_return\"]\nxdp-pass-all-nodes       pass              {}             50         {\"primarynodeinterface\":true}   [\"drop\"]\n</code></pre> <p>The priority setting determines the order in which programs attached to the same interface are executed by the dispatcher with a lower number being a higher priority.  The <code>go-xdp-counter-example</code> program was loaded at priority 55, so the <code>xdp-pass-all-nodes</code> program will execute before the <code>go-xdp-counter-example</code> program.</p> <p>The proceedon setting tells the dispatcher whether to \"proceed\" to execute the next lower priority program attached to the same interface depending on the program's return value.  When we set proceedon to drop, execution will proceed only if the program returns <code>XDP_DROP</code>.  However, the <code>xdp-pass-all-nodes</code> program only returns <code>XDP_PASS</code>, so execution will terminate after it runs.</p> <p>Therefore, by loading the <code>xdp-pass-all-nodes</code> program in this way, we should have effectively stopped the <code>go-xdp-counter-example</code> program from running.  Let's confirm that.</p> <p>11. Verify that packet counts are not being updated anymore</p> <p>Run the following command several times</p> <pre><code>kubectl logs go-xdp-counter-ds-9lpgp -n go-xdp-counter | tail\n</code></pre> <pre><code>2023/09/05 17:10:27 1395 packets received\n2023/09/05 17:10:27 13799730 bytes received\n\n2023/09/05 17:10:30 1395 packets received\n2023/09/05 17:10:30 13799730 bytes received\n\n2023/09/05 17:10:33 1395 packets received\n2023/09/05 17:10:33 13799730 bytes received\n</code></pre> <p>12. Now, change the priority of the xdp-pass program to 60</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: bpfd.io/v1alpha1\nkind: XdpProgram\nmetadata:\nlabels:\napp.kubernetes.io/name: xdpprogram\nname: xdp-pass-all-nodes\nspec:\nname: pass\n# Select all nodes\nnodeselector: {}\ninterfaceselector:\nprimarynodeinterface: true\npriority: 60\nproceedon:\n- drop\nbytecode:\nimage:\nurl: quay.io/bpfd-bytecode/xdp_pass:latest\nEOF\n</code></pre> <p>13. Confirm that packets are being counted again</p> <p>Run the following command several times</p> <pre><code>kubectl logs go-xdp-counter-ds-9lpgp -n go-xdp-counter | tail\n</code></pre> <pre><code>2023/09/05 17:12:21 1435 packets received\n2023/09/05 17:12:21 13806214 bytes received\n\n2023/09/05 17:12:24 1505 packets received\n2023/09/05 17:12:24 13815359 bytes received\n\n2023/09/05 17:12:27 1558 packets received\n2023/09/05 17:12:27 13823065 bytes received\n</code></pre> <p>We can see that the counters are incrementing again.</p> <p>14. Clean everything up</p> <p>Delete the programs</p> <pre><code>kubectl delete xdpprogram xdp-pass-all-nodes\nkubectl delete -f https://github.com/bpfd-dev/bpfd/releases/download/v0.2.0/go-xdp-counter-install-v0.2.0.yaml\n</code></pre> <p>And/or, delete the whole kind cluster</p> <pre><code>kind delete clusters test-bpfd\n</code></pre>"},{"location":"blog/2023/09/07/bpfd-a-novel-way-to-manage-ebpf/#joining-the-bpfd-community","title":"Joining the bpfd community","text":"<p>If you're interested in bpfd and want to get involved, you can connect with the community in multiple ways. If you have some simple questions or need some help feel free to start a discussion. If you find an issue, or you want to request a new feature, please create an issue. If you want something a little more synchronous, the project maintains a <code>#bpfd</code> channel on Kubernetes Slack and we have a weekly community meeting where everyone can join and bring topics to discuss about the project. We hope to see you there!</p>"},{"location":"developer-guide/api-spec/","title":"API Specification","text":""},{"location":"developer-guide/configuration/","title":"Configuration","text":""},{"location":"developer-guide/configuration/#bpfd-configuration-file","title":"bpfd Configuration File","text":"<p>bpfd looks for a configuration file to be present at <code>/etc/bpfd/bpfd.toml</code>. If no file is found, defaults are assumed. There is an example at <code>scripts/bpfd.toml</code>, similar to:</p> <pre><code>[tls] # REQUIRED\nca_cert = \"/etc/bpfd/certs/ca/ca.pem\"\ncert = \"/etc/bpfd/certs/bpfd/bpfd.pem\"\nkey = \"/etc/bpfd/certs/bpfd/bpfd.key\"\nclient_cert = \"/etc/bpfd/certs/bpfd-client/bpfd-client.pem\"\nclient_key = \"/etc/bpfd/certs/bpfd-client/bpfd-client.key\"\n[interfaces]\n[interface.eth0]\nxdp_mode = \"hw\" # Valid xdp modes are \"hw\", \"skb\" and \"drv\". Default: \"skb\".\n[[grpc.endpoints]]\ntype = \"tcp\"\nenabled = true\naddress = \"::1\"\nport = 50051\n[[grpc.endpoints]]\ntype = \"unix\"\nenabled = false\npath = \"/run/bpfd/bpfd.sock\"\n</code></pre> <p><code>bpfctl</code> and <code>bpfd-agent</code> (which is only used in Kubernetes type deployments) will also read the bpfd configuration file (<code>/etc/bpfd/bpfd.toml</code>) to retrieve the bpfd-client certificate file locations.</p>"},{"location":"developer-guide/configuration/#config-section-tls","title":"Config Section: [tls]","text":"<p>This section of the configuration file allows the mTLS certificate authority file locations to be overwritten. If the given certificates exist, then bpfd will use them. Otherwise, bpfd will create them. Default values are shown above.</p> <p>Valid fields:</p> <ul> <li>ca_cert: Certificate authority file location, intended to be used by bpfd and client.</li> <li>cert: Certificate file location, intended to be used by bpfd.</li> <li>key: Certificate key location, intended to be used by bpfd.</li> <li>client_cert: Client certificate file location, intended to be used by bpfd clients (<code>bpfctl</code>, <code>bpfd-agent</code>, etc).</li> <li>client_key: Client certificate key file location, intended to be used by bpfd clients (<code>bpfctl</code>, <code>bpfd-agent</code>, etc).</li> </ul> <p>If bpfd is running as a systemd service, then the certificates must be accessible by bpfd (owned by the bpfd User and User Group).</p>"},{"location":"developer-guide/configuration/#config-section-interfaces","title":"Config Section: [interfaces]","text":"<p>This section of the configuration file allows the XDP Mode for a given interface to be set. If not set, the default value of <code>skb</code> will be used. Multiple interfaces can be configured.</p> <pre><code>[interfaces]\n[interfaces.eth0]\nxdp_mode = \"drv\"\n[interfaces.eth1]\nxdp_mode = \"hw\"\n[interfaces.eth2]\nxdp_mode = \"skb\"\n</code></pre> <p>Valid fields:</p> <ul> <li>xdp_mode: XDP Mode for a given interface. Valid values: [\"drv\"|\"hw\"|\"skb\"]</li> </ul>"},{"location":"developer-guide/configuration/#config-section-grpcendpoints","title":"Config Section: [grpc.endpoints]","text":"<p>In this section different endpoints can be configured for bpfd to listen on. We currently support TCP sockets with IPv4 and Ipv6 addresses and Unix domain sockets. When using TCP sockets, the tls configuration will be used to secure communication. Unix domain sockets provide a simpler communication with no encryption. These sockets are owned by the bpfd user and user group when running as a systemd or non-root process.</p> <p>Valid fields:</p> <ul> <li>type: Specify if the endpoint will listen on a TCP or Unix domain socket. Valid values: [\"tcp\"|\"unix\"]</li> <li>enabled: Configure whether bpfd should listen on the endpoint. Valid values: [\"true\"|\"false\"]</li> <li>address: Exclusive to TCP sockets. Specify the address the endpoint should listen on. Valid values: Any valid IPv4 or IPv6 address.</li> <li>port: Exclusive to TCP sockets. Specify the port bpfd should listen on. Valid values: An integer between 1024 and 65535.</li> <li>path: Exclusive to Unix sockets. Specify the path where the socket will be created. Valid values: A valid unix path.</li> </ul>"},{"location":"developer-guide/debugging/","title":"Debugging using VSCode and lldb on a remote machine or VM","text":"<ol> <li>Install code-lldb vscode extension</li> <li> <p>Add a configuration to <code>.vscode/launch.json</code> like the following (customizing for a given system using the comment in the configuration file):</p> <pre><code>    {\n\"name\": \"Remote debug bpfd\",\n\"type\": \"lldb\",\n\"request\": \"launch\",\n\"program\": \"&lt;ABSOLUTE_PATH&gt;/github.com/bpfd-dev/bpfd/target/debug/bpfd\", // Local path to latest debug binary.\n\"initCommands\": [\n\"platform select remote-linux\", // Execute `platform list` for a list of available remote platform plugins.\n\"platform connect connect://&lt;IP_ADDRESS_OF_VM&gt;:8081\", // replace &lt;IP_ADDRESS_OF_VM&gt;\n\"settings set target.inherit-env false\",\n],\n\"env\": {\n\"RUST_LOG\": \"debug\"\n},\n\"cargo\": {\n\"args\": [\n\"build\",\n\"--bin=bpfd\",\n\"--package=bpfd\"\n],\n\"filter\": {\n\"name\": \"bpfd\",\n\"kind\": \"bin\"\n}\n},\n\"cwd\": \"${workspaceFolder}\",\n},\n</code></pre> </li> <li> <p>On the VM or Server install <code>lldb-server</code>:</p> <p><code>dnf</code> based OS: <pre><code>    sudo dnf install lldb\n</code></pre></p> <p><code>apt</code> based OS:</p> <pre><code>    sudo apt install lldb\n</code></pre> </li> <li> <p>Start <code>lldb-server</code> on the VM or Server (make sure to do this in the <code>~/home</code> directory)</p> <pre><code>    cd ~\n    sudo lldb-server platform --server --listen 0.0.0.0:8081\n</code></pre> </li> <li> <p>Add breakpoints as needed via the vscode GUI and then hit <code>F5</code> to start debugging!</p> </li> </ol>"},{"location":"developer-guide/develop-operator/","title":"Developing the bpfd-operator","text":"<p>This section is intended to give developer level details regarding the layout and design of the bpfd-operator. At its core the operator was implemented using the operator-sdk framework which make those docs another good resource if anything is missed here.</p>"},{"location":"developer-guide/develop-operator/#high-level-design-overview","title":"High level design overview","text":"<p>This repository houses two main processes, the <code>bpfd-agent</code> and the <code>bpfd-operator</code> along with CRD api definitions for <code>BpfProgram</code> and <code>*Program</code> Objects. The following diagram depicts how all these components work together to create a functioning operator.</p> <p></p>"},{"location":"developer-guide/develop-operator/#building-and-deploying","title":"Building and deploying","text":"<p>For building and deploying the bpfd-operator simply see the attached <code>Make help</code> output.</p> <pre><code> make help\nUsage:\n  make &lt;target&gt;\n\nGeneral\n  help             Display this help.\n\nLocal Dependencies\n  kustomize        Download kustomize locally if necessary.\n  cm-verifier      Download cm-verifier locally if necessary.\n  controller-gen   Download controller-gen locally if necessary.\n  envtest          Download envtest-setup locally if necessary.\n  opm              Download opm locally if necessary.\n\nDevelopment\n  manifests        Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects.\n  generate         Generate ALL auto-generated code.\n  generate-register  Generate register code see all `zz_generated.register.go` files.\n  generate-deepcopy  Generate code containing DeepCopy, DeepCopyInto, and DeepCopyObject method implementations see all `zz_generated.register.go` files.\n  generate-typed-clients  Generate typed client code\n  generate-typed-listers  Generate typed listers code\n  generate-typed-informers  Generate typed informers code\n  fmt              Run go fmt against code.\n  verify           Verify all the autogenerated code\n  lint             Run golang-ci linter\n  test             Run Unit tests.\n  test-integration  Run Integration tests.\n  bundle           Generate bundle manifests and metadata, then validate generated files.\n\nBuild\n  build            Build bpfd-operator and bpfd-agent binaries.\n  build-images     Build bpfd, bpfd-agent, and bpfd-operator images.\n  push-images      Push bpfd, bpfd-agent, bpfd-operator images.\n  load-images-kind  Load bpfd, bpfd-agent, and bpfd-operator images into the running local kind devel cluster.\n  bundle-build     Build the bundle image.\n  bundle-push      Push the bundle image.\n  catalog-build    Build a catalog image.\n  catalog-push     Push a catalog image.\n\nCRD Deployment\n  install          Install CRDs into the K8s cluster specified in ~/.kube/config.\n  uninstall        Uninstall CRDs from the K8s cluster specified in ~/.kube/config. Call with ignore-not-found=true to ignore resource not found errors during deletion.\n\nDeployment Dependencies\n  deploy-certmanager  Deploy certmanager to the cluster specified in ~/.kube/config.\n  undeploy-certmanager  Undeploy certmanager from the cluster specified in ~/.kube/config. Call with ignore-not-found=true to ignore resource not found errors during deletion.\n\nVanilla K8s Deployment\n  setup-kind       Setup Kind cluster with certmanager ready for bpfd deployment\n  deploy           Deploy bpfd-operator to the K8s cluster specified in ~/.kube/config.\n  undeploy         Undeploy bpfd-operator from the K8s cluster specified in ~/.kube/config. Call with ignore-not-found=true to ignore resource not found errors during deletion.\n  kind-reload-images  Reload locally build images into a kind cluster and restart the ds and deployment so they're picked up.\n  run-on-kind      Kind Deploy runs the bpfd-operator on a local kind cluster using local builds of bpfd, bpfd-agent, and bpfd-operator\n\nOpenshift Deployment\n  deploy-openshift  Deploy bpfd-operator to the Openshift cluster specified in ~/.kube/config.\n  undeploy-openshift  Undeploy bpfd-operator from the Openshift cluster specified in ~/.kube/config. Call with ignore-not-found=true to ignore resource not found errors during deletion.\n</code></pre>"},{"location":"developer-guide/develop-operator/#running-locally-in-kind","title":"Running Locally in KIND","text":"<p>To run locally in a kind cluster with an up to date build simply run:</p> <pre><code>make run-on-kind\n</code></pre> <p>The container images used for <code>bpfd</code>,<code>bpfd-agent</code>, and <code>bpfd-operator</code> can also be manually configured, by default local image builds will be used for the kind deployment.</p> <pre><code>BPFD_IMG=&lt;your/image/url&gt; BPFD_AGENT_IMG=&lt;your/image/url&gt; BPFD_OPERATOR_IMG=&lt;your/image/url&gt; make run-on-kind\n</code></pre> <p>Then rebuild and load a fresh build run:</p> <pre><code>make kind-reload-images\n</code></pre> <p>Which will rebuild the bpfd-operator, bpfd-agent, and bpfd images and load them into the kind cluster.</p>"},{"location":"developer-guide/develop-operator/#testing-locally","title":"Testing Locally","text":"<p>To run all of the Unit Tests defined in the bpfd-operator controller code simply run <code>make test</code>.</p> <p>To run Integration Tests locally:</p> <ol> <li>Build the images locally with the <code>int-test</code> tag.</li> </ol> <pre><code>    BPFD_AGENT_IMG=quay.io/bpfd/bpfd-agent:int-test BPFD_IMG=quay.io/bpfd/bpfd:int-test BPFD_OPERATOR_IMG=quay.io/bpfd/bpfd-operator:int-test make build-images\n</code></pre> <ol> <li>Run the integration test suite.</li> </ol> <pre><code>    BPFD_AGENT_IMG=quay.io/bpfd/bpfd-agent:int-test BPFD_IMG=quay.io/bpfd/bpfd:int-test BPFD_OPERATOR_IMG=quay.io/bpfd/bpfd-operator:int-test make test-integration\n</code></pre> <p>Additionally the integration test can be configured with the following environment variables:</p> <ul> <li>KEEP_TEST_CLUSTER: If set to <code>true</code> the test cluster will not be torn down after the integration test   suite completes.</li> <li>USE_EXISTING_KIND_CLUSTER: If this is set to the name of the existing kind cluster the integration test   suite will use that cluster instead of creating a new one.</li> </ul>"},{"location":"developer-guide/develop-operator/#project-layout","title":"Project Layout","text":"<p>The bpfd-operator project layout is guided by the recommendations from both the operator-sdk framework and the standard golang project-layout. The following is a brief description of the main directories and their contents.</p> <p>NOTE: Bolded directories contain auto-generated code</p> <ul> <li><code>/apis</code>: Contains the K8s CRD api definitions(<code>*_types.go</code>) for each version along with the   auto-generated register and deepcopy methods(<code>zz_generated.deepcopy.go</code> and <code>zz_generate_register.go</code>).</li> <li><code>/bundle</code>: Contains the OLM bundle manifests and metadata for the operator.   More details can be found in the operator-sdk documentation.</li> <li><code>/cmd</code>: Contains the main entry-points for the bpfd-operator and bpfd-agent processes.</li> <li><code>/config</code>: Contains the configuration files for launching the bpfd-operator on a cluster.<ul> <li><code>/bpfd-deployment</code>: Contains static deployment yamls for the bpfd-daemon, this includes two containers,   one for <code>bpfd</code> and the other for the <code>bpfd-agent</code>.   This DaemonSet yaml is NOT deployed statically by kustomize, instead it's statically copied into the operator   image which is then responsible for deploying and configuring the bpfd-daemon DaemonSet.   Lastly, this directory also contains the default config used to configure the bpfd-daemon, along with the   cert-manager certificates used to encrypt communication between the bpfd-agent and bpfd.</li> <li><code>/bpfd-operator-deployment:</code> Contains the static deployment yaml for the bpfd-operator. This is deployed   statically by kustomize.</li> <li><code>/cert-manager</code>: Contains the cert-manager manifests used to deploy cert-manager to a cluster.   Specifically it just contains a symlink to it's manifests locking us into a specific version.</li> <li><code>/crd</code>: Contains the CRD manifests for all of the bpfd-operator APIs.<ul> <li><code>/bases</code>: Is where the actual CRD definitions are stored. These definitions are auto-generated by controller-gen.</li> </ul> </li> <li><code>/default</code>: Contains the default deployment configuration for the bpfd-operator.</li> <li><code>/manifests</code>: Contains the bases for generating OLM manifests.</li> <li><code>/openshift</code>: Contains the Openshift specific deployment configuration for the bpfd-operator.</li> <li><code>/prometheus</code>: Contains the prometheus manifests used to deploy Prometheus to a cluster.   At the time of writing this the bpfd-operator is NOT exposing any metrics to prometheus, but this is a future goal.</li> <li><code>/rbac</code>: Contains rbac yamls for getting bpfd and the bpfd-operator up and running on Kubernetes.     <code>/bpfd-agent</code>: Contains the rbac yamls for the bpfd-agent.     They are automatically generated by kubebuilder via build tags in the bpfd-agent controller code.     <code>/bpfd-operator</code>: Contains the rbac yamls for the bpfd-operator.     They are automatically generated by kubebuilder via build tags in the bpfd-operator controller code.</li> <li><code>/samples</code>: Contains sample CR definitions that can be deployed by users for each of our supported APIs.</li> <li><code>/scorecard</code>: Contains the scorecard manifests used to deploy scorecard to a cluster. At the time of writing   this the bpfd-operator is NOT running any scorecard tests.</li> <li><code>/test</code>: Contains the test manifests used to deploy the bpfd-operator to a kind cluster for integration testing.</li> </ul> </li> <li><code>/controllers</code>: Contains the controller implementations for all of the bpfd-operator APIs.   Each controller is responsible for reconciling the state of the cluster with the desired state defined by the user.   This is where the source of truth for the auto-generated RBAC can be found, keep an eye out for   <code>//+kubebuilder:rbac:groups=bpfd.dev</code> comment tags.<ul> <li><code>/bpfdagent</code>: Contains the controller implementations which reconcile user created <code>*Program</code> types to multiple   <code>BpfProgram</code> objects.</li> <li><code>/bpfdoperator</code>: Contains the controller implementations which reconcile global <code>BpfProgram</code> object state back to   the user by ensuring the user created <code>*Program</code> objects are reporting the correct status.</li> </ul> </li> <li><code>/hack</code>: Contains any scripts+static files used by the bpfd-operator to facilitate development.</li> <li><code>/internal</code>: Contains all private library code and is used by the bpfd-operator and bpfd-agent controllers.</li> <li><code>/pkg</code>: Contains all public library code this is consumed externally and internally.<ul> <li><code>/client</code>: Contains the autogenerated clientset, informers and listers for all of the bpfd-operator APIs.   These are autogenerated by the k8s.io/code-generator project,   and can be consumed by users wishing to programmatically interact with bpfd specific APIs.</li> <li><code>/helpers</code>: Contains helper functions which can be consumed by users wishing to programmatically interact with   bpfd specific APIs.</li> </ul> </li> <li><code>/test/integration</code>: Contains integration tests for the bpfd-operator.   These tests are run against a kind cluster and are responsible for testing the bpfd-operator in a real cluster   environment.   It uses the kubernetes-testing-framework project to   programmatically spin-up all of the required infrastructure for our unit tests.</li> <li><code>Makefile</code>: Contains all of the make targets used to build, test, and generate code used by the bpfd-operator.</li> </ul>"},{"location":"developer-guide/documentation/","title":"Documentation","text":"<p>This section describes how to modify the related documentation around bpfd. All bpfd's documentation is written in Markdown, and leverages mkdocs to generate a static site, which is hosted on netlify.</p> <p>If this is the first time building using <code>mkdocs</code>, jump to the Development Environment Setup section for help installing the tooling.</p>"},{"location":"developer-guide/documentation/#documentation-notes","title":"Documentation Notes","text":"<p>This section describes some notes on the dos and don'ts when writing documentation.</p>"},{"location":"developer-guide/documentation/#website-management","title":"Website Management","text":"<p>The headings and layout of the website, as well as other configuration settings, are managed from the mkdocs.yml file in the project root directory.</p>"},{"location":"developer-guide/documentation/#markdown-style","title":"Markdown Style","text":"<p>When writing documentation via a Markdown file, the following format has been followed:</p> <ul> <li>Text on a given line should not exceed 100 characters, unless it's example syntax or a link   that should be broken up.</li> <li>Each new sentence should start on a new line.   That way, if text needs to be inserted, whole paragraphs don't need to be adjusted.</li> <li>Links to other markdown files are relative to the file the link is placed in.</li> </ul>"},{"location":"developer-guide/documentation/#governance-files","title":"Governance Files","text":"<p>There are a set of well known governance files that are typically placed in the root directory of most projects, like README.md, MAINTAINERS.md, CONTRIBUTING.md, etc. <code>mkdocs</code> expects all files used in the static website to be located under a common directory, <code>docs/</code> for bpfd. To reference the governance files from the static website, a directory (<code>docs/governance/</code>) was created with a file for each governance file, the only contains <code>--8&lt;--</code> and the file name. This indicates to <code>mkdocs</code> to pull the additional file from the project root directory.</p> <p>For example: docs/governance/MEETINGS.md</p> <p>NOTE: This works for the website generation, but if a Markdown file is viewed through   Github (not the website), the link is broken.   So these files should only be linked from <code>docs/index.md</code> and <code>mkdocs.yml</code>.</p>"},{"location":"developer-guide/documentation/#docsdeveloper-guideapi-specmd","title":"docs/developer-guide/api-spec.md","text":"<p>The file docs/developer-guide/api-spec.md documents the CRDs used in a Kubernetes deployment. The contents are auto-generated when PRs are pushed to Github. The script scripts/make-docs.sh manages the generation of this file.</p>"},{"location":"developer-guide/documentation/#generate-documentation","title":"Generate Documentation","text":"<p>On each PR pushed to https://github.com/bpfd-dev/bpfd the documentation is generated. To preview of the generated site, click on the <code>Details</code> link of the <code>netlify/bpfd/deploy-preview</code> Check from the Github GUI.</p> <p>If you would like to test locally, build and preview the generated documentation, from the bpfd root directory, use <code>mkdocs</code> to build:</p> <pre><code>cd bpfd/\nmkdocs build\n</code></pre> <p>To preview from a build on a local machine, start the mkdocs dev-server with the command below, then open up <code>http://127.0.0.1:8000/</code> in your browser, and you'll see the default home page being displayed:</p> <pre><code>mkdocs serve\n</code></pre> <p>To preview from a build on a remote machine, start the mkdocs dev-server with the command below, then open up <code>http://&lt;ServerIP&gt;:8000/</code> in your browser, and you'll see the default home page being displayed:</p> <pre><code>mkdocs serve -a 0.0.0.0:8000\n</code></pre>"},{"location":"developer-guide/documentation/#development-environment-setup","title":"Development Environment Setup","text":"<p>The recommended installation method is using <code>pip</code>.</p> <pre><code>pip install mkdocs\npip install pymdown-extensions\npip install mkdocs-material\n</code></pre> <p>Once installed, ensure the <code>mkdocs</code> is in your PATH:</p> <pre><code>mkdocs -V\nmkdocs, version 1.4.3 from /home/$USER/.local/lib/python3.11/site-packages/mkdocs (Python 3.11)\n</code></pre>"},{"location":"developer-guide/image-build/","title":"bpfd Container Images","text":"<p>Container images for the <code>bpfd</code> and <code>bpfctl</code> binaries are automatically built and pushed to <code>quay.io/bpfd</code> whenever code is merged into the <code>main</code> branch of the <code>github.com/bpfd-dev/bpfd</code> repository under the <code>:latest</code> tag.</p>"},{"location":"developer-guide/image-build/#building-the-images-locally","title":"Building the images locally","text":""},{"location":"developer-guide/image-build/#bpfd","title":"bpfd","text":"<pre><code>docker build -f /packaging/container-deployment/Containerfile.bpfd . -t bpfd:local\n</code></pre>"},{"location":"developer-guide/image-build/#bpfctl","title":"bpfctl","text":"<pre><code>docker build -f /packaging/container-deployment/Containerfile.bpfctl . -t bpfctl:local\n</code></pre>"},{"location":"developer-guide/image-build/#running-locally-in-container","title":"Running locally in container","text":""},{"location":"developer-guide/image-build/#bpfd_1","title":"bpfd","text":"<pre><code>sudo docker run --init --privileged --net=host -v /etc/bpfd/certs/:/etc/bpfd/certs/ -v /sys/fs/bpf:/sys/fs/bpf quay.io/bpfd/bpfd:latest\n</code></pre>"},{"location":"developer-guide/image-build/#bpfctl_1","title":"bpfctl","text":"<pre><code>sudo docker run --init --privileged --net=host -v /etc/bpfd/certs/:/etc/bpfd/certs/ quay.io/bpfd/bpfctl:latest &lt;COMMANDS&gt;\n</code></pre>"},{"location":"developer-guide/linux-capabilities/","title":"Linux Capabilities","text":"<p>Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled. Capabilities are a per-thread attribute. See capabilities man-page.</p> <p>When <code>bpfd</code> is run as a systemd service, the set of linux capabilities are restricted to only the required set of capabilities via the <code>bpfd.service</code> file using the <code>AmbientCapabilities</code> and <code>CapabilityBoundingSet</code> fields (see bpfd.service). All spawned threads are stripped of all capabilities, removing all sudo privileges (see <code>drop_linux_capabilities()</code> usage), leaving only the main thread with only the needed set of capabilities.</p>"},{"location":"developer-guide/linux-capabilities/#debugging-linux-capabilities","title":"Debugging Linux Capabilities","text":"<p>As new features are added, the set of Linux capabilities required by bpfd may change over time. The following describes the steps to determine the set of capabilities required by bpfd. If there are any <code>Permission denied (os error 13)</code> type errors when starting or running bpfd as a systemd service, adjusting the linux capabilities is a good place to start.</p>"},{"location":"developer-guide/linux-capabilities/#determine-required-capabilities","title":"Determine Required Capabilities","text":"<p>The first step is to turn all capabilities on and see if that fixes the problem. This can be done without recompiling the code by editing <code>bpfd.service</code>. Comment out the finite list of granted capabilities and set to <code>~</code>,  which indicates all capabilities.</p> <pre><code>sudo vi /usr/lib/systemd/system/bpfd.service\n:\n[Service]\n:\nAmbientCapabilities=~\nCapabilityBoundingSet=~\n#AmbientCapabilities=CAP_BPF CAP_DAC_OVERRIDE CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SETPCAP CAP_SYS_ADMIN CAP_SYS_RESOURCE\n#CapabilityBoundingSet=CAP_BPF CAP_DAC_OVERRIDE CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SETPCAP CAP_SYS_ADMIN CAP_SYS_RESOURCE\n</code></pre> <p>Reload the service file and start/restart bpfd and watch the bpfd logs and see if the problem is resolved:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl start bpfd\n</code></pre> <p>If so, then the next step is to watch the set of capabilities being requested by bpfd. Run the bcc <code>capable</code> tool to watch capabilities being requested real-time and restart bpfd:</p> <pre><code>$ sudo /usr/share/bcc/tools/capable\nTIME      UID    PID    COMM             CAP  NAME                 AUDIT\n:\n16:36:00  979    75553  tokio-runtime-w  8    CAP_SETPCAP          1\n16:36:00  979    75553  tokio-runtime-w  8    CAP_SETPCAP          1\n16:36:00  979    75553  tokio-runtime-w  8    CAP_SETPCAP          1\n16:36:00  0      616    systemd-journal  19   CAP_SYS_PTRACE       1\n16:36:00  0      616    systemd-journal  19   CAP_SYS_PTRACE       1\n16:36:00  979    75550  bpfd             24   CAP_SYS_RESOURCE     1\n16:36:00  979    75550  bpfd             1    CAP_DAC_OVERRIDE     1\n16:36:00  979    75550  bpfd             21   CAP_SYS_ADMIN        1\n16:36:00  979    75550  bpfd             21   CAP_SYS_ADMIN        1\n16:36:00  0      75555  modprobe         16   CAP_SYS_MODULE       1\n16:36:00  0      628    systemd-udevd    2    CAP_DAC_READ_SEARCH  1\n16:36:00  0      75556  bpf_preload      24   CAP_SYS_RESOURCE     1\n16:36:00  0      75556  bpf_preload      39   CAP_BPF              1\n16:36:00  0      75556  bpf_preload      39   CAP_BPF              1\n16:36:00  0      75556  bpf_preload      39   CAP_BPF              1\n16:36:00  0      75556  bpf_preload      38   CAP_PERFMON          1\n16:36:00  0      75556  bpf_preload      38   CAP_PERFMON          1\n16:36:00  0      75556  bpf_preload      38   CAP_PERFMON          1\n:\n</code></pre> <p>Compare the output to list in <code>bpfd.service</code> and determine the delta.</p>"},{"location":"developer-guide/linux-capabilities/#determine-capabilities-per-thread","title":"Determine Capabilities Per Thread","text":"<p>For additional debugging, it may be helpful to know the granted capabilities on a per thread basis. As mentioned above, all spawned threads are stripped of all Linux capabilities, so if a thread is requesting a capability, that functionality should be moved off the spawned thread and onto the main thread.</p> <p>First, determine the <code>bpfd</code> process id, then determine the set of threads:</p> <pre><code>$ ps -ef | grep bpfd\n:\nbpfd       75550       1  0 16:36 ?        00:00:00 /usr/sbin/bpfd\n:\n\n$ ps -T -p 75550\nPID    SPID TTY          TIME CMD\n  75550   75550 ?        00:00:00 bpfd\n  75550   75551 ?        00:00:00 tokio-runtime-w\n  75550   75552 ?        00:00:00 tokio-runtime-w\n  75550   75553 ?        00:00:00 tokio-runtime-w\n  75550   75554 ?        00:00:00 tokio-runtime-w\n</code></pre> <p>Then dump the capabilities of each thread:</p> <pre><code>$ grep Cap /proc/75550/status\nCapInh: 000000c001201106\nCapPrm: 000000c001201106\nCapEff: 000000c001201106\nCapBnd: 000000c001201106\nCapAmb: 000000c001201106\n\n$ grep Cap /proc/75551/status\nCapInh: 0000000000000000\nCapPrm: 0000000000000000\nCapEff: 0000000000000000\nCapBnd: 0000000000000000\nCapAmb: 0000000000000000\n\n$ grep Cap /proc/75552/status\nCapInh: 0000000000000000\nCapPrm: 0000000000000000\nCapEff: 0000000000000000\nCapBnd: 0000000000000000\nCapAmb: 0000000000000000\n\n:\n\n$ capsh --decode=000000c001201106\n0x000000c001201106=cap_dac_override,cap_dac_read_search,cap_setpcap,cap_net_admin,cap_sys_admin,cap_sys_resource,cap_perfmon,cap_bpf\n</code></pre>"},{"location":"developer-guide/linux-capabilities/#removing-cap_bpf-from-bpfd-clients","title":"Removing CAP_BPF from bpfd Clients","text":"<p>One of the advantages of using bpfd is that it is doing all the loading and unloading of eBPF programs, so it requires CAP_BPF, but clients of bpfd are just making gRPC calls to bpfd, so they do not need to be privileged or require CAP_BPF. It must be noted that this is only true for kernels 5.19 or higher. Prior to kernel 5.19, all eBPF sys calls required CAP_BPF, which are used to access maps shared between the BFP program and the userspace program. In kernel 5.19, a change went in that only requires CAP_BPF for map creation (BPF_MAP_CREATE) and loading programs (BPF_PROG_LOAD). See bpf: refine kernel.unprivileged_bpf_disabled behaviour.</p>"},{"location":"developer-guide/logging/","title":"Logging","text":"<p>This section describes how to enable logging in different <code>bpfd</code> deployments.</p>"},{"location":"developer-guide/logging/#local-privileged-bpfd-process","title":"Local Privileged Bpfd Process","text":"<p><code>bpfd</code> and <code>bpfctl</code> use the env_logger crate to log messages to the terminal. By default, only <code>error</code> messages are logged, but that can be overwritten by setting the <code>RUST_LOG</code> environment variable. Valid values:</p> <ul> <li><code>error</code></li> <li><code>warn</code></li> <li><code>info</code></li> <li><code>debug</code></li> <li><code>trace</code></li> </ul> <p>Example:</p> <pre><code>$ sudo RUST_LOG=info /usr/local/bin/bpfd\n[2022-08-08T20:29:31Z INFO  bpfd] Log using env_logger\n[2022-08-08T20:29:31Z INFO  bpfd::server] Loading static programs from /etc/bpfd/programs.d\n[2022-08-08T20:29:31Z INFO  bpfd::server::bpf] Map veth12fa8e3 to 13\n[2022-08-08T20:29:31Z INFO  bpfd::server] Listening on [::1]:50051\n[2022-08-08T20:29:31Z INFO  bpfd::server::bpf] Program added: 1 programs attached to veth12fa8e3\n[2022-08-08T20:29:31Z INFO  bpfd::server] Loaded static program pass with UUID d9fd88df-d039-4e64-9f63-19f3e08915ce\n</code></pre> <p><code>bpfctl</code> has a minimal set of logs, but the infrastructure is in place if needed for future debugging.</p> <pre><code>sudo RUST_LOG=info bpfctl list\n[2023-05-09T12:46:59Z WARN  bpfctl] Unable to read config file, using defaults\n[2023-05-09T12:46:59Z INFO  bpfctl] Using UNIX socket as transport\n Program ID  Name  Type  Load Time\n</code></pre>"},{"location":"developer-guide/logging/#systemd-service","title":"Systemd Service","text":"<p>If <code>bpfd</code> is running as a systemd service, then <code>bpfd</code> will log to journald. As with env_logger, by default, <code>info</code> and higher messages are logged, but that can be overwritten by setting the <code>RUST_LOG</code> environment variable. <code>bpfctl</code> won't be run as a service, so it always uses env_logger.</p> <p>Example:</p> <pre><code>sudo vi /usr/lib/systemd/system/bpfd.service\n[Unit]\nDescription=Run bpfd as a service\nDefaultDependencies=no\nAfter=network.target\n[Service]\nEnvironment=\"RUST_LOG=Info\"    &lt;==== Set Log Level Here\nExecStart=/usr/sbin/bpfd\nMemoryAccounting=true\nMemoryLow=infinity\nMemoryMax=infinity\nUser=bpfd\nGroup=bpfd\nAmbientCapabilities=CAP_BPF CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SYS_ADMIN CAP_SYS_RESOURCE\nCapabilityBoundingSet=CAP_BPF CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SYS_ADMIN CAP_SYS_RESOURCE\n</code></pre> <p>Start the service:</p> <pre><code>sudo systemctl start bpfd.service\n</code></pre> <p>Check the logs:</p> <pre><code>$ sudo journalctl -f -u bpfd\nAug 08 16:25:04 ebpf03 systemd[1]: Started bpfd.service - Run bpfd as a service.\nAug 08 16:25:04 ebpf03 bpfd[180118]: Log using journald\nAug 08 16:25:04 ebpf03 bpfd[180118]: Loading static programs from /etc/bpfd/programs.d\nAug 08 16:25:04 ebpf03 bpfd[180118]: Map veth12fa8e3 to 13\nAug 08 16:25:04 ebpf03 bpfd[180118]: Listening on [::1]:50051\nAug 08 16:25:04 ebpf03 bpfd[180118]: Program added: 1 programs attached to veth12fa8e3\nAug 08 16:25:04 ebpf03 bpfd[180118]: Loaded static program pass with UUID a3ffa14a-786d-48ad-b0cd-a4802f0f10b6\n</code></pre> <p>Stop the service:</p> <pre><code>sudo systemctl stop bpfd.service\n</code></pre>"},{"location":"developer-guide/logging/#kubernetes-deployment","title":"Kubernetes Deployment","text":"<p>When <code>bpfd</code> is run in a Kubernetes deployment, there is the bpfd Daemonset that runs on every node and the bpd Operator that runs on the control plane:</p> <pre><code>kubectl get pods -A\nNAMESPACE            NAME                                                    READY   STATUS    RESTARTS   AGE\nbpfd                 bpfd-daemon-dgqzw                                       2/2     Running   0          3d22h\nbpfd                 bpfd-daemon-gqsgd                                       2/2     Running   0          3d22h\nbpfd                 bpfd-daemon-zx9xr                                       2/2     Running   0          3d22h\nbpfd                 bpfd-operator-7fbf4888c4-z8w76                          2/2     Running   0          3d22h\n:\n</code></pre>"},{"location":"developer-guide/logging/#bpfd-daemonset","title":"bpfd Daemonset","text":"<p><code>bpfd</code> and <code>bpfd-agent</code> are running in the bpfd daemonset.</p>"},{"location":"developer-guide/logging/#view-logs","title":"View Logs","text":"<p>To view the <code>bpfd</code> logs:</p> <pre><code>kubectl logs -n bpfd bpfd-daemon-dgqzw -c bpfd\n[2023-05-05T14:41:26Z INFO  bpfd] Log using env_logger\n[2023-05-05T14:41:26Z INFO  bpfd] Has CAP_BPF: false\n[2023-05-05T14:41:26Z INFO  bpfd] Has CAP_SYS_ADMIN: true\n:\n</code></pre> <p>To view the <code>bpfd-agent</code> logs:</p> <pre><code>kubectl logs -n bpfd bpfd-daemon-dgqzw -c bpfd-agent\n2023-05-05T14:41:27Z    INFO    controller-runtime.metrics  Metrics server is starting to listen    {\"addr\": \":8080\"}\n2023-05-05T14:41:27Z    INFO    tls-internal    Reading...\n    {\"Default config path\": \"/etc/bpfd/bpfd.toml\"}\n2023-05-05T14:41:27Z    INFO    setup   Waiting for active connection to bpfd at %s {\"addr\": \"localhost:50051\", \"creds\": {}}\n:\n</code></pre>"},{"location":"developer-guide/logging/#change-log-level","title":"Change Log Level","text":"<p>To change the log level of the agent or daemon, edit the <code>bpfd-config</code> ConfigMap. The <code>bpfd-operator</code> will detect the change and restart the bpfd daemonset with the updated values.</p> <pre><code>kubectl edit configmaps -n bpfd bpfd-config\napiVersion: v1\ndata:\n  bpfd.agent.image: quay.io/bpfd/bpfd-agent:latest\n  bpfd.image: quay.io/bpfd/bpfd:latest\n  bpfd.log.level: info                     &lt;==== Set bpfd Log Level Here\n  bpfd.agent.log.level: info               &lt;==== Set bpfd agent Log Level Here\n  bpfd.toml: |\n    [[grpc.endpoints]]\n    type = \"unix\"\n    path = \"/bpfd-sock/bpfd.sock\"\n    enabled = true\nkind: ConfigMap\nmetadata:\n  creationTimestamp: \"2023-05-05T14:41:19Z\"\n  name: bpfd-config\n  namespace: bpfd\n  resourceVersion: \"700803\"\n  uid: 0cc04af4-032c-4712-b824-748b321d319b\n</code></pre> <p>Valid values for the daemon (<code>bpfd.log.level</code>) are:</p> <ul> <li><code>error</code></li> <li><code>warn</code></li> <li><code>info</code></li> <li><code>debug</code></li> <li><code>trace</code></li> </ul> <p><code>trace</code> can be very verbose. More information can be found regarding Rust's env_logger here.</p> <p>Valid values for the agent (<code>bpfd.agent.log.level</code>) are:</p> <ul> <li><code>info</code></li> <li><code>debug</code></li> <li><code>trace</code></li> </ul>"},{"location":"developer-guide/logging/#bpfd-operator","title":"bpfd Operator","text":"<p>The bpfd Operator is running as a Deployment with a ReplicaSet of one. It runs with the containers <code>bpfd-operator</code> and <code>kube-rbac-proxy</code>.</p>"},{"location":"developer-guide/logging/#view-logs_1","title":"View Logs","text":"<p>To view the <code>bpfd-operator</code> logs:</p> <pre><code>kubectl logs -n bpfd bpfd-operator-7fbf4888c4-z8w76 -c bpfd-operator\n{\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"logger\":\"controller-runtime.metrics\",\"msg\":\"Metrics server is starting to listen\",\"addr\":\"127.0.0.1:8080\"}\n{\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"logger\":\"setup\",\"msg\":\"starting manager\"}\n{\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"msg\":\"Starting server\",\"kind\":\"health probe\",\"addr\":\"[::]:8081\"}\n{\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"msg\":\"Starting server\",\"path\":\"/metrics\",\"kind\":\"metrics\",\"addr\":\"127.0.0.1:8080\"}\nI0509 18:37:11.262885       1 leaderelection.go:248] attempting to acquire leader lease bpfd/8730d955.bpfd.dev...\nI0509 18:37:11.268918       1 leaderelection.go:258] successfully acquired lease bpfd/8730d955.bpfd.dev\n{\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"msg\":\"Starting EventSource\",\"controller\":\"configmap\",\"controllerGroup\":\"\",\"controllerKind\":\"ConfigMap\",\"source\":\"kind source: *v1.ConfigMap\"}\n:\n</code></pre> <p>To view the <code>kube-rbac-proxy</code> logs:</p> <pre><code>kubectl logs -n bpfd bpfd-operator-7fbf4888c4-z8w76 -c kube-rbac-proxy\nI0509 18:37:11.063386       1 main.go:186] Valid token audiences: \nI0509 18:37:11.063485       1 main.go:316] Generating self signed cert as no cert is provided\nI0509 18:37:11.955256       1 main.go:366] Starting TCP socket on 0.0.0.0:8443\nI0509 18:37:11.955849       1 main.go:373] Listening securely on 0.0.0.0:8443\n</code></pre>"},{"location":"developer-guide/logging/#change-log-level_1","title":"Change Log Level","text":"<p>To change the log level, edit the <code>bpfd-operator</code> Deployment. The change will get detected and the bpfd operator pod will get restarted with the updated log level.</p> <pre><code>kubectl edit deployment -n bpfd bpfd-operator\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  annotations:\n    deployment.kubernetes.io/revision: \"1\"\n    kubectl.kubernetes.io/last-applied-configuration: |\n      {\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\"metadata\":{\"annotations\":{},\"labels\":{\"app.kubernetes.io/component\":\"manager\",\"app.kubernetes.io/create&gt;\n  creationTimestamp: \"2023-05-09T18:37:08Z\"\n  generation: 1\n:\nspec:\n:\n  template:\n    metadata:\n:\n    spec:\n      containers:\n      - args:\n:\n      - args:\n        - --health-probe-bind-address=:8081\n        - --metrics-bind-address=127.0.0.1:8080\n        - --leader-elect\n        command:\n        - /bpfd-operator\n        env:\n        - name: GO_LOG\n          value: info                   &lt;==== Set Log Level Here\n        image: quay.io/bpfd/bpfd-operator:latest\n        imagePullPolicy: IfNotPresent\n:\n</code></pre> <p>Valid values are:</p> <ul> <li><code>error</code></li> <li><code>info</code></li> <li><code>debug</code></li> <li><code>trace</code></li> </ul>"},{"location":"developer-guide/operator-quick-start/","title":"Deploying the bpfd-operator","text":"<p>The <code>bpfd-operator</code> repository exists in order to deploy and manage bpfd within a Kubernetes cluster.</p>"},{"location":"developer-guide/operator-quick-start/#getting-started","title":"Getting Started","text":"<p>This operator was built utilizing some great tooling provided by the operator-sdk library. A great first step in understanding some of the functionality can be to just run <code>make help</code>.</p>"},{"location":"developer-guide/operator-quick-start/#deploy-locally-via-kind","title":"Deploy Locally via KIND","text":"<p>After reviewing the possible make targets it's quick and easy to get bpfd deployed locally on your system via a KIND cluster with:</p> <pre><code>make run-on-kind\n</code></pre>"},{"location":"developer-guide/operator-quick-start/#deploy-to-openshift-cluster","title":"Deploy To Openshift Cluster","text":"<p>First deploy the operator with one of the following two options:</p>"},{"location":"developer-guide/operator-quick-start/#1-manually-with-kustomize","title":"1. Manually with Kustomize","text":"<p>To install manually with Kustomize and raw manifests simply run:</p> <pre><code>make deploy-openshift\n</code></pre> <p>Which can then be cleaned up with:</p> <pre><code>make undeploy-openshift\n</code></pre>"},{"location":"developer-guide/operator-quick-start/#2-via-the-olm-bundle","title":"2. Via the OLM bundle","text":"<p>The bpfd-operator can also be installed via it's OLM bundle.</p> <p>First setup the namespace and certificates for the operator with:</p> <pre><code>oc apply -f ./hack/ocp-scc-hacks.yaml\n</code></pre> <p>Then use <code>operator-sdk</code> to install the bundle like so:</p> <pre><code>operator-sdk run bundle quay.io/bpfd/bpfd-operator-bundle:latest --namespace openshift-bpfd\n</code></pre> <p>To clean everything up run:</p> <pre><code>operator-sdk cleanup bpfd-operator\n</code></pre> <p>followed by</p> <pre><code>oc delete -f ./hack/ocp-scc-hacks.yaml\n</code></pre>"},{"location":"developer-guide/operator-quick-start/#verify-the-installation","title":"Verify the Installation","text":"<p>If the bpfd-operator came up successfully you will see the bpfd-daemon and bpfd-operator pods running without errors:</p> <pre><code>kubectl get pods -n bpfd\nNAME                             READY   STATUS    RESTARTS   AGE\nbpfd-daemon-bt5xm                2/2     Running   0          130m\nbpfd-daemon-ts7dr                2/2     Running   0          129m\nbpfd-daemon-w24pr                2/2     Running   0          130m\nbpfd-operator-78cf9c44c6-rv7f2   2/2     Running   0          132m\n</code></pre>"},{"location":"developer-guide/operator-quick-start/#deploy-an-ebpf-program-to-the-cluster","title":"Deploy an eBPF Program to the cluster","text":"<p>To test the deployment simply deploy one of the sample <code>xdpPrograms</code>:</p> <pre><code>kubectl apply -f config/samples/bpfd.io_v1alpha1_xdp_pass_xdpprogram.yaml\n</code></pre> <p>If loading of the XDP Program to the selected nodes was successful it will be reported back to the user via the <code>xdpProgram</code>'s status field:</p> <pre><code>kubectl get xdpprogram xdp-pass-all-nodes -o yaml\napiVersion: bpfd.dev/v1alpha1\n  kind: XdpProgram\n  metadata:\n    creationTimestamp: \"2023-05-04T18:28:46Z\"\nfinalizers:\n    - bpfd.dev.operator/finalizer\n    generation: 1\nlabels:\n      app.kubernetes.io/name: xdpprogram\n    name: xdp-pass-all-nodes\n    resourceVersion: \"11205\"\nuid: 8246b56c-b78e-43fc-bb78-3b46b1490a0c\n  spec:\n    bytecode:\n      image:\n        imagepullpolicy: IfNotPresent\n        url: quay.io/bpfd-bytecode/xdp_pass:latest\n    interfaceselector:\n      primarynodeinterface: true\nnodeselector: {}\npriority: 0\nproceedon:\n    - pass\n    - dispatcher_return\n    name: pass\n  status:\n    conditions:\n    - lastTransitionTime: \"2023-05-04T18:28:46Z\"\nmessage: bpfProgramReconciliation Succeeded on all nodes\n      reason: ReconcileSuccess\n      status: \"True\"\ntype: ReconcileSuccess\nkind: List\nmetadata:\n  resourceVersion: \"\"\n</code></pre> <p>To see more information in listing form simply run:</p> <pre><code>kubectl get xdpprogram -o wide\nNAME                 BPFFUNCTIONNAME   BYTECODE                                                                                     NODESELECTOR   PRIORITY   INTERFACESELECTOR               PROCEEDON\nxdp-pass-all-nodes   pass              {\"image\":{\"imagepullpolicy\":\"IfNotPresent\",\"url\":\"quay.io/bpfd-bytecode/xdp_pass:latest\"}}   {}             0          {\"primarynodeinterface\":true}   [\"pass\",\"dispatcher_return\"]\n</code></pre>"},{"location":"developer-guide/operator-quick-start/#api-types-overview","title":"API Types Overview","text":"<p>See api-spec.md for a more detailed description of all the bpfd Kubernetes API types.</p>"},{"location":"developer-guide/operator-quick-start/#multiple-program-crds","title":"Multiple Program CRDs","text":"<p>The multiple <code>*Program</code> CRDs are the bpfd Kubernetes API objects most relevant to users and can be used to understand clusterwide state for an eBPF program. It's designed to express how, and where eBPF programs are to be deployed within a Kubernetes cluster. Currently bpfd supports the use of <code>xdpProgram</code>, <code>tcProgram</code> and <code>tracepointProgram</code> objects.</p>"},{"location":"developer-guide/operator-quick-start/#bpfprogram-crd","title":"BpfProgram CRD","text":"<p>The <code>BpfProgram</code> CRD is used internally by the bpfd-deployment to keep track of per node bpfd state such as map pin points, and to report node specific errors back to the user. Kubernetes users/controllers are only allowed to view these objects, NOT create or edit them.</p> <p>Applications wishing to use bpfd to deploy/manage their eBPF programs in Kubernetes will make use of this object to find references to the bpfMap pin points (<code>spec.maps</code>) in order to configure their eBPF programs.</p>"},{"location":"developer-guide/release/","title":"Release Process","text":""},{"location":"developer-guide/release/#overview","title":"Overview","text":"<p>A release for the bpfd project is comprised of the following major components:</p> <ul> <li>bpfd + bpfctl binaries</li> <li>Core GRPC API protobuf definitions</li> <li>Kubernetes Custom Resource Definitions (CRDs)</li> <li>Corresponding go pkg in the form of <code>github.com/bpfd-dev/bpfd</code> which includes the following:</li> <li><code>github.com/bpfd-dev/bpfd/clients/gobpfd/v1</code>: The go client for the bpfd GRPC API</li> <li><code>github.com/bpfd-dev/bpfd/bpfd-operator/apis</code>: The go bindings for the     bpfd CRD API</li> <li><code>github.com/bpfd-dev/bpfd/bpfd-operator/pkg/client</code>: The autogenerated     clientset for the bpfd CRD API</li> <li><code>github.com/bpfd-dev/bpfd/bpfd-operator/pkg/helpers</code>: The provided bpfd CRD     API helpers.</li> <li>Corresponding <code>bpfd-api</code>, <code>bpfd</code>, and <code>bpfctl</code> rust crates which house the rust client for the bpfd GRPC API</li> <li>The following core component container images with tag : <li><code>quay.io/bpfd/bpfd</code></li> <li><code>quay.io/bpfd/bpfctl</code></li> <li><code>quay.io/bpfd/bpfd-operator</code></li> <li><code>quay.io/bpfd/bpfd-agent</code></li> <li><code>quay.io/bpfd/bpfd-operator-bundle</code></li> <li><code>quay.io/bpfd/xdp-dispatcher</code></li> <li>The relevant example bytecode container images with tag  from source   code located in the bpfd project: <li><code>quay.io/bpfd-bytecode/go_xdp_counter</code></li> <li><code>quay.io/bpfd-bytecode/go_tc_counter</code></li> <li><code>quay.io/bpfd-bytecode/go_tracepoint_counter</code></li> <li><code>quay.io/bpfd-bytecode/xdp_pass</code></li> <li><code>quay.io/bpfd-bytecode/tc_pass</code></li> <li><code>quay.io/bpfd-bytecode/tracepoint</code></li> <li><code>quay.io/bpfd-bytecode/xdp_pass_private</code></li> <li><code>quay.io/bpfd-bytecode/uprobe</code></li> <li><code>quay.io/bpfd-bytecode/kprobe</code></li> <li><code>quay.io/bpfd-bytecode/uretprobe</code></li> <li><code>quay.io/bpfd-bytecode/kretprobe</code></li> <li>The relevant example userspace container images with tag  from source   code located in the bpfd project: <li><code>quay.io/bpfd-userspace/go_xdp_counter</code></li> <li><code>quay.io/bpfd-userspace/go_tc_counter</code></li> <li><code>quay.io/bpfd-userspace/go_tracepoint_counter</code></li> <li>The OLM (Operator Lifecycle Manager) for the Kubernetes Operator.</li> <li>This includes a <code>bundle</code> directory on disk as well as the     <code>quay.io/bpfd/bpfd-operator-bundle</code> with the tag ."},{"location":"developer-guide/release/#versioning-strategy","title":"Versioning strategy","text":""},{"location":"developer-guide/release/#overview_1","title":"Overview","text":"<p>Each new release of bpfd is defined with a \"bundle version\" that represents the Git tag of a release, such as <code>v0.4.0</code>. This contains the components described above</p>"},{"location":"developer-guide/release/#kubernetes-api-versions-eg-v1alpha2-v1beta1","title":"Kubernetes API Versions (e.g. v1alpha2, v1beta1)","text":"<p>Within the bpfd-operator, API versions are primarily used to indicate the stability of a resource. For example, if a resource has not yet graduated to beta, it is still possible that it could either be removed from the API or changed in backwards incompatible ways. For more information on API versions, refer to the full Kubernetes API versioning documentation.</p>"},{"location":"developer-guide/release/#releasing-a-new-version","title":"Releasing a new version","text":""},{"location":"developer-guide/release/#writing-a-changelog","title":"Writing a Changelog","text":"<p>To simplify release notes generation, we recommend using the Kubernetes release notes generator:</p> <pre><code>go install k8s.io/release/cmd/release-notes@latest\nexport GITHUB_TOKEN=your_token_here\nrelease-notes --start-sha EXAMPLE_COMMIT --end-sha EXAMPLE_COMMIT --branch main --repo bpfd --org bpfd-dev\n</code></pre> <p>This output will likely need to be reorganized and cleaned up a bit, but it provides a good starting point. Once you're satisfied with the changelog, create a PR. This must go through the regular PR review process and get merged into the <code>main</code> branch. Approval of the PR indicates community consensus for a new release.</p>"},{"location":"developer-guide/release/#release-steps","title":"Release Steps","text":"<p>The following steps must be done by one of the bpfd maintainers:</p> <p>For a PATCH release:</p> <ul> <li>Create a new branch in your fork named something like <code>&lt;githubuser&gt;/release-x.x.x</code>. Use the new branch   in the upcoming steps.</li> <li>Use <code>git</code> to cherry-pick all relevant PRs into your branch.</li> <li>Create a branch from the major-minor tag of interest i.e:   <code>git checkout -b release-x.x.x &lt;major.minor.patch&gt;</code></li> <li>Create a pull request of the <code>&lt;githubuser&gt;/release-x.x.x</code> branch into the <code>release-x.x</code> branch upstream.   Add a hold on this PR waiting for at least one maintainer/codeowner to provide a <code>lgtm</code>. This PR should:</li> <li>Add a new changelog for the release</li> <li>Update the cargo.toml versions for the bpfd-api, bpfd, and bpfctl crates</li> <li>Update the bpfd-operator version in it's MAKEFILE and run <code>make bundle</code> to update the bundle version.     This will generate a new <code>/bpfd-operator/bundle</code> directory which will ONLY be tracked in the     <code>release-x.x</code> branch not <code>main</code>.</li> <li>Verify the CI tests pass and merge the PR into <code>release-x.x</code>.</li> <li>Create a tag using the <code>HEAD</code> of the <code>release-x.x.x</code> branch. This can be done using the <code>git</code> CLI or   Github's release page.</li> <li>The Release will be automatically created, after that is complete do the following:</li> <li>run <code>make build-crd-install-yaml</code> and attach the crd install yaml for the version to the release.</li> <li>manually build and attach a <code>bpfd-operator-install-vx.x.x.yaml</code> to provide an easy to use install     yaml for the bpfd-operator.</li> <li>manually build and attach the following files:<ul> <li><code>go-xdp-counter-install-vx.x.x.yaml</code></li> <li><code>go-tc-counter-install-vx.x.x.yaml</code></li> <li><code>go-tracepoint-counter-install-vx.x.x.yaml</code> so that the examples for a given release can be easily deployed.</li> </ul> </li> <li>Update the community-operator and   community-operators-prod repositories with   the latest bundle manifests. See the following PRs as examples:<ul> <li>https://github.com/redhat-openshift-ecosystem/community-operators-prod/pull/2696</li> <li>https://github.com/k8s-operatorhub/community-operators/pull/2790</li> </ul> </li> </ul> <p>For a MAJOR or MINOR release:</p> <ul> <li>Open an update PR that:</li> <li>Adds a new changelog for the release</li> <li>Updates the cargo.toml versions for the bpfd-api, bpfd, and bpfctl crates</li> <li>Updates the bpfd-operator version in it's MAKEFILE and run <code>make bundle</code> to update the bundle version</li> <li>Add's a new <code>examples</code> config directory for the release version</li> <li>Make sure CI is green and merge the update PR.</li> <li>Create a tag using the <code>HEAD</code> of the <code>main</code> branch. This can be done using the <code>git</code> CLI or   Github's release page.</li> <li>Tag the release using the commit on <code>main</code> where the changelog update merged.   This can  be done using the <code>git</code> CLI or Github's release   page.</li> <li>The Release will be automatically created, after that is complete do the following:</li> <li>run <code>make build-crd-install-yaml</code> and attach the crd install yaml for the version to the release.</li> <li>manually build and attach a <code>bpfd-operator-install-vx.x.x.yaml</code> to provide an easy to use install     yaml for the bpfd-operator.</li> <li>manually build and attach the following files:<ul> <li><code>go-xdp-counter-install-vx.x.x.yaml</code></li> <li><code>go-tc-counter-install-vx.x.x.yaml</code></li> <li><code>go-tracepoint-counter-install-vx.x.x.yaml</code> so that the examples for a given release can be easily deployed.</li> </ul> </li> </ul>"},{"location":"developer-guide/shipping-bytecode/","title":"eBPF Bytecode Image Specifications","text":""},{"location":"developer-guide/shipping-bytecode/#introduction","title":"Introduction","text":"<p>The eBPF Bytecode Image specification defines how to package eBPF bytecode as container images. The initial primary use case focuses on the containerization and deployment of eBPF programs within container orchestration systems such as Kubernetes, where it is necessary to provide a portable way to distribute bytecode to all nodes which need it.</p>"},{"location":"developer-guide/shipping-bytecode/#specifications","title":"Specifications","text":"<p>We provide two distinct spec variants here to ensure interoperatiblity with existing registries and packages which do no support the new custom media types defined here.</p> <ul> <li>custom-data-type-spec</li> <li>backwards-compatable-spec</li> </ul>"},{"location":"developer-guide/shipping-bytecode/#backwards-compatible-oci-compliant-spec","title":"Backwards compatible OCI compliant spec","text":"<p>This variant makes use of existing OCI conventions to represent eBPF Bytecode as container images.</p>"},{"location":"developer-guide/shipping-bytecode/#image-layers","title":"Image Layers","text":"<p>The container images following this variant must contain exactly one layer who's media type is one of the following:</p> <ul> <li><code>application/vnd.oci.image.layer.v1.tar+gzip</code> or the compliant <code>application/vnd.docker.image.rootfs.diff.tar.gzip</code></li> </ul> <p>Additionally the image layer must contain a valid eBPF object file (generally containing a <code>.o</code> extension) placed at the root of the layer <code>./</code>.</p>"},{"location":"developer-guide/shipping-bytecode/#image-labels","title":"Image Labels","text":"<p>To provide relevant metadata regarding the bytecode to any consumers, some relevant labels MUST be defined on the image.</p> <p>These labels are defined as follows:</p> <ul> <li> <p><code>io.ebpf.program_type</code>: The eBPF program type (i.e <code>xdp</code>,<code>tc</code>, <code>sockops</code>, ...).</p> </li> <li> <p><code>io.ebpf.filename</code>: The Filename of the bytecode stored in the image.</p> </li> <li> <p><code>io.ebpf.program_name</code>: The name of the eBPF Program represented in the bytecode.</p> </li> <li> <p><code>io.ebpf.bpf_function_name</code>: The name of the function that is the entry point for the BPF program.</p> </li> </ul>"},{"location":"developer-guide/shipping-bytecode/#building-a-backwards-compatible-oci-compliant-image","title":"Building a Backwards compatible OCI compliant image","text":"<p>An Example Containerfile can be found at <code>/packaging/container/deployment/Containerfile.bytecode</code></p> <p>To use the provided templated Containerfile simply run a <code>docker build</code> command like the following:</p> <pre><code>docker build \\\n--build-arg PROGRAM_NAME=xdp_pass \\\n--build-arg BPF_FUNCTION_NAME=pass \\\n--build-arg PROGRAM_TYPE=xdp \\\n--build-arg BYTECODE_FILENAME=pass.bpf.o \\\n--build-arg KERNEL_COMPILE_VER=$(uname -r) \\\n-f packaging/container-deployment/Containerfile.bytecode \\\n/home/&lt;USER&gt;/bytecode -t quay.io/&lt;USER&gt;/xdp_pass:latest\n</code></pre> <p>Where <code>/home/&lt;USER&gt;/bytecode</code> is the directory the bytecode object file is located.</p> <p>Users can also use <code>skopeo</code> to ensure the image follows the backwards compatible version of the spec:</p> <ul> <li><code>skopeo inspect</code> will show the correctly configured labels stored in the configuration layer (<code>application/vnd.oci.image.config.v1+json</code>) of the image.</li> </ul> <pre><code>skopeo inspect docker://quay.io/astoycos/xdp_pass:latest\n{\n\"Name\": \"quay.io/&lt;USER&gt;/xdp_pass\",\n    \"Digest\": \"sha256:db1f7dd03f9fba0913e07493238fcfaf0bf08de37b8e992cc5902775dfb9086a\",\n    \"RepoTags\": [\n\"latest\"\n],\n    \"Created\": \"2022-08-14T14:27:20.147468277Z\",\n    \"DockerVersion\": \"\",\n    \"Labels\": {\n\"io.buildah.version\": \"1.26.1\",\n        \"io.ebpf.filename\": \"pass.bpf.o\",\n        \"io.ebpf.program_name\": \"xdp_counter\",\n        \"io.ebpf.program_type\": \"xdp\",\n        \"io.ebpf.bpf_function_name\": \"pass\"\n},\n    \"Architecture\": \"amd64\",\n    \"Os\": \"linux\",\n    \"Layers\": [\n\"sha256:5f6dae6f567601fdad15a936d844baac1f30c31bd3df8df0c5b5429f3e048000\"\n],\n    \"Env\": [\n\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"\n]\n}\n</code></pre> <ul> <li><code>skopeo inspect --raw</code> will show the correct layer type is used in the image.</li> </ul> <pre><code>skopeo inspect --raw  docker://quay.io/astoycos/xdp_pass:latest\n{\"schemaVersion\":2,\"mediaType\":\"application/vnd.oci.image.manifest.v1+json\",\"config\":{\"mediaType\":\"application/vnd.oci.image.config.v1+json\",\"digest\":\"sha256:ff4108b8405a877b2df3e06f9287c509b9d62d6c241c9a5213d81a9abee80361\",\"size\":2385},\"layers\":[{\"mediaType\":\"application/vnd.oci.image.layer.v1.tar+gzip\",\"digest\":\"sha256:5f6dae6f567601fdad15a936d844baac1f30c31bd3df8df0c5b5429f3e048000\",\"size\":1539}],\"annotations\":{\"org.opencontainers.image.base.digest\":\"sha256:86b59a6cf7046c624c47e40a5618b383d763be712df2c0e7aaf9391c2c9ef559\",\"org.opencontainers.image.base.name\":\"\"}}\n</code></pre>"},{"location":"developer-guide/shipping-bytecode/#custom-oci-compatible-spec","title":"Custom OCI compatible spec","text":"<p>This variant of the eBPF bytecode image spec uses custom OCI medium types to represent eBPF bytecode as container images. Many toolchains and registries may not support this yet.</p> <p>TODO(astoycos)</p>"},{"location":"developer-guide/testing/","title":"Testing","text":"<p>This document describes the automated testing that is done for each pull request submitted to bpfd.</p>"},{"location":"developer-guide/testing/#unit-testing","title":"Unit Testing","text":"<p>Unit testing is executed as part of the <code>build</code> job  by running the <code>cargo test</code> command in the top-level bpfd directory.</p>"},{"location":"developer-guide/testing/#go-example-tests","title":"Go Example Tests","text":"<p>Tests are run for each of the example programs found in directory <code>examples</code></p> <p>Detailed description TBD</p>"},{"location":"developer-guide/testing/#basic-integration-tests","title":"Basic Integration Tests","text":"<p>The full set of basic integration tests are executed by running the following command in the top-level bpfd directory.</p> <pre><code>cargo xtask integration-test\n</code></pre> <p>Optionally, a subset of the integration tests can be run by adding the \"--\" and a list of one or more names at the end of the command as shown below.</p> <pre><code>cargo xtask integration-test -- test_load_unload_xdp test_proceed_on_xdp\n</code></pre> <p>The integration tests start a <code>bpfd</code> daemon process, and issue <code>bpfctl</code> commands to verify a range of functionality.  For XDP and TC programs that are installed on network interfaces, the integration test code creates a test network namespace connected to the host by a veth pair on which the programs are attached. The test code uses the IP subnet 172.37.37.1/24 for the namespace. If that address conflicts with an existing network on the host, it can be changed by setting the <code>BPFD_IP_PREFIX</code> environment variable to one that is available as shown below.</p> <pre><code>export BPFD_IP_PREFIX=\"192.168.50\"\n</code></pre> <p>If bpfd logs are needed to help debug an integration test, set <code>RUST_LOG</code> either globally or for a given test.</p> <p><pre><code>export RUST_LOG=info\n</code></pre> OR <pre><code>RUST_LOG=info cargo xtask integration-test -- test_load_unload_xdp test_proceed_on_xdp\n</code></pre></p> <p>There are two categories of integration tests: basic and e2e.  The basic tests verify basic <code>bpfctl</code> functionality such as loading, listing, and unloading programs.  The e2e tests verify more advanced functionality such as the setting of global variables, priority, and proceed-on by installing the programs, creating traffic if needed, and examining logs to confirm that things are running as expected.</p> <p>Most eBPF test programs are loaded from container images stored on quay.io. The source code for the eBPF test programs can be found in the <code>tests/integration-test/bpf</code> directory.  These programs are compiled by executing <code>cargo xtask build-ebpf --libbpf-dir &lt;libbpf dir&gt;</code></p> <p>We also load some tests from local files to test the <code>load-from-file</code> option.</p> <p>The <code>bpf</code> directory also contains a script called <code>build_push_images.sh</code> that can be used to build and push new images to quay if the code is changed.  We plan to push the images automatically when code gets merged (issue #533). However, it's still useful to be able to push them manually sometimes. For example, when a new test case requires that both the eBPF and integration code be changed together.  It is also a useful template for new eBPF test code that needs to be pushed. However, as a word of caution, be aware that existing integration tests will start using the new programs immediately, so this should only be done if the modified program is backward compatible.</p>"},{"location":"developer-guide/testing/#kubernetes-integration-tests","title":"Kubernetes Integration Tests","text":"<p>Detailed decription TBD</p>"},{"location":"getting-started/bpfctl-guide/","title":"bpfctl Guide","text":"<p><code>bpfctl</code> is the command line tool for interacting with <code>bpfd</code>. <code>bpfctl</code> allows the user to <code>load</code>, <code>unload</code>, <code>get</code> and <code>list</code> eBPF programs.</p>"},{"location":"getting-started/bpfctl-guide/#notes-for-this-guide","title":"Notes For This Guide","text":"<p>As described in other sections, <code>bpfd</code> can be run as either a privileged process or a systemd service. If run as a privileged process, <code>bpfctl</code> will most likely be run from your local development branch and will require <code>sudo</code>. Example:</p> <pre><code>sudo ./target/debug/bpfctl list\n</code></pre> <p>If run as a systemd service, <code>bpfctl</code> will most likely be installed in your $PATH, the <code>bpfd</code> user and user group were created, so the usergroup <code>bpfd</code> will need to be added to the desired user. Then <code>sudo</code> is no longer required. Example:</p> <pre><code>sudo usermod -a -G bpfd $USER\nexit\n&lt;LOGIN&gt;\nbpfctl list\n</code></pre> <p>The examples here use <code>bpfctl</code> in place of <code>sudo ./target/debug/bpfctl</code> for readability, use as your system is deployed.</p>"},{"location":"getting-started/bpfctl-guide/#bpfctl-load-from-file-with-bpfd-as-a-systemd-service","title":"bpfctl load-from-file With bpfd As A Systemd Service","text":"<p>For security reasons, when <code>bpfd</code> is run as a systemd service, all linux capabilities are stripped from any spawned threads. Therefore, <code>bpfd</code> can only access files owned by the <code>bpfd</code> user group. This includes eBPF object files. In the <code>bpfctl load-from-file</code> examples below, the files are located in <code>/run/bpfd/examples/</code>, which is a directory owned by <code>bpfd</code>. Below is an example of copying local files over for use in this scenario:</p> <pre><code>sudo cp /$HOME/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o /run/bpfd/examples/.\nsudo cp /$HOME/src/net-ebpf-playground/.output/filter.bpf.o /run/bpfd/examples/.\nsudo chown bpfd:bpfd -R /run/bpfd/examples/\n</code></pre> <p>This is only needed if <code>bpfd</code> is run as a systemd service. When <code>sudo ./scripts/setup.sh install</code> is run to launch bpfd as a systemd service, all the eBPF object files from the <code>examples/</code> directory are copied to <code>/run/bpfd/examples/</code>.</p>"},{"location":"getting-started/bpfctl-guide/#basic-syntax","title":"Basic Syntax","text":"<p>Below are the commands supported by <code>bpfctl</code>.</p> <pre><code>bpfctl --help\nA client for working with bpfd\nUsage: bpfctl &lt;COMMAND&gt;\n------\nCommands:\n---------\n  load-from-file   Load an eBPF program from a local .o file\n  load-from-image  Load an eBPF program packaged in a OCI container image from a given registry\n  unload           Unload an eBPF program using the program id\n  list             List all eBPF programs loaded via bpfd\n  get              Get a program's metadata by program id\n  pull-bytecode    Pull a bytecode image for future use by a load command\n  help             Print this message or the help of the given subcommand(s)\nOptions:\n--------\n  -h, --help     Print help\n  -V, --version  Print version\n</code></pre>"},{"location":"getting-started/bpfctl-guide/#bpfctl-load","title":"bpfctl load","text":"<p>The <code>bpfctl load-from-file</code> and <code>bpfctl load-from-image</code> commands are used to load eBPF programs. The <code>bpfctl load-from-file</code> command is used to load a locally built eBPF program. The <code>bpfctl load-from-image</code> command is used to load an eBPF progam packaged in a OCI container image from a given registry. Each program type (i.e. <code>&lt;COMMAND&gt;</code>) has it's own set of attributes specific to the program type, and those attributes MUST come after the program type is entered. There are a common set of attributes, and those MUST come before the program type is entered.</p> <pre><code>bpfctl load-from-file --help\nLoad an eBPF program from a local .o file\nUsage: bpfctl load-from-file [OPTIONS] --path &lt;PATH&gt; --name &lt;NAME&gt; &lt;COMMAND&gt;\n------\nCommands:\n---------\n  xdp         Install an eBPF program on the XDP hook point for a given interface\n  tc          Install an eBPF program on the TC hook point for a given interface\n  tracepoint  Install an eBPF program on a Tracepoint\n  kprobe      Install an eBPF kprobe or kretprobe\n  uprobe      Install an eBPF uprobe or uretprobe\n  help        Print this message or the help of the given subcommand(s)\nOptions:\n--------\n  -p, --path &lt;PATH&gt;\n          Required: Location of local bytecode file\n          Example: --path /run/bpfd/examples/go-xdp-counter/bpf_bpfel.o\n  -n, --name &lt;NAME&gt;\n          Required: The name of the function that is the entry point for the BPF program\n  -g, --global &lt;GLOBAL&gt;...\n          Optional: Global variables to be set when program is loaded.\n          Format: &lt;NAME&gt;=&lt;Hex Value&gt;\n          This is a very low level primitive. The caller is responsible for formatting\n          the byte string appropriately considering such things as size, endianness,\n          alignment and packing of data structures.\n  -m, --metadata &lt;METADATA&gt;\n          Optional: Specify Key/Value metadata to be attached to a program when it\n          is loaded by bpfd.\n          Format: &lt;KEY&gt;=&lt;VALUE&gt;\n          This can later be used to list a certain subset of programs which contain\n          the specified metadata.\n      --map-owner-id &lt;MAP_OWNER_ID&gt;\n          Optional: Program id of loaded eBPF program this eBPF program will share a map with.\n          Only used when multiple eBPF programs need to share a map.\n          Example: --map-owner-id 63178\n  -h, --help\n          Print help (see a summary with '-h')\n</code></pre> <p>and </p> <pre><code>bpfctl load-from-image --help\nLoad an eBPF program packaged in a OCI container image from a given registry\nUsage: bpfctl load-from-image [OPTIONS] --image-url &lt;IMAGE_URL&gt; &lt;COMMAND&gt;\nCommands:\n  xdp         Install an eBPF program on the XDP hook point for a given interface\n  tc          Install an eBPF program on the TC hook point for a given interface\n  tracepoint  Install an eBPF program on a Tracepoint\n  kprobe      Install an eBPF kprobe or kretprobe\n  uprobe      Install an eBPF uprobe or uretprobe\n  help        Print this message or the help of the given subcommand(s)\nOptions:\n  -i, --image-url &lt;IMAGE_URL&gt;\n          Required: Container Image URL.\n          Example: --image-url quay.io/bpfd-bytecode/xdp_pass:latest\n  -r, --registry-auth &lt;REGISTRY_AUTH&gt;\n          Optional: Registry auth for authenticating with the specified image registry.\n          This should be base64 encoded from the '&lt;username&gt;:&lt;password&gt;' string just like\n          it's stored in the docker/podman host config.\n          Example: --registry_auth \"YnjrcKw63PhDcQodiU9hYxQ2\"\n  -p, --pull-policy &lt;PULL_POLICY&gt;\n          Optional: Pull policy for remote images.\n          [possible values: Always, IfNotPresent, Never]\n          [default: IfNotPresent]\n  -n, --name &lt;NAME&gt;\n          Optional: The name of the function that is the entry point for the BPF program.\n          If not provided, the program name defined as part of the bytecode image will be used.\n          [default: ]\n  -g, --global &lt;GLOBAL&gt;...\n          Optional: Global variables to be set when program is loaded.\n          Format: &lt;NAME&gt;=&lt;Hex Value&gt;\n          This is a very low level primitive. The caller is responsible for formatting\n          the byte string appropriately considering such things as size, endianness,\n          alignment and packing of data structures.\n  -m, --metadata &lt;METADATA&gt;\n          Optional: Specify Key/Value metadata to be attached to a program when it\n          is loaded by bpfd.\n          Format: &lt;KEY&gt;=&lt;VALUE&gt;\n          This can later be used to list a certain subset of programs which contain\n          the specified metadata.\n          Example: --metadata owner=acme\n      --map-owner-id &lt;MAP_OWNER_ID&gt;\n          Optional: Program id of loaded eBPF program this eBPF program will share a map with.\n          Only used when multiple eBPF programs need to share a map.\n          Example: --map-owner-id 63178\n  -h, --help\n          Print help (see a summary with '-h')\n</code></pre> <p>When using either load command, <code>--path</code>, <code>--image-url</code>, <code>--registry-auth</code>, <code>--pull-policy</code>, <code>--name</code>,  <code>--global</code>, <code>--metadata</code> and <code>--map-owner-id</code> must be entered before the <code>&lt;COMMAND&gt;</code> (<code>xdp</code>, <code>tc</code>,  <code>tracepoint</code>, etc) is entered. Then each <code>&lt;COMMAND&gt;</code> has its own custom parameters (same for both <code>bpfctl load-from-file</code> and <code>bpfctl load-from-image</code>):</p> <pre><code>bpfctl load-from-file xdp --help\nInstall an eBPF program on the XDP hook point for a given interface\nUsage: bpfctl load-from-file --path &lt;PATH&gt; --name &lt;NAME&gt; xdp [OPTIONS] --iface &lt;IFACE&gt; --priority &lt;PRIORITY&gt;\n------\nOptions:\n--------\n  -i, --iface &lt;IFACE&gt;\n          Required: Interface to load program on\n  -p, --priority &lt;PRIORITY&gt;\n          Required: Priority to run program in chain. Lower value runs first\n      --proceed-on &lt;PROCEED_ON&gt;...\n          Optional: Proceed to call other programs in chain on this exit code.\n          Multiple values supported by repeating the parameter.\n          Example: --proceed-on \"pass\" --proceed-on \"drop\"\n          [possible values: aborted, drop, pass, tx, redirect, dispatcher_return]\n          [default: pass, dispatcher_return]\n  -h, --help\n          Print help (see a summary with '-h')\n</code></pre> <p>Example loading from local file:</p> <pre><code>bpfctl load-from-file --path /run/bpfd/examples/xdp_pass_kern.o --name \"pass\" xdp --iface vethb2795c7 --priority 100\n</code></pre> <p>Example from image in remote repository (Note: <code>--name</code> is built into the image and is not required):</p> <pre><code>bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100\n</code></pre> <p>The <code>tc</code> command is similar to <code>xdp</code>, but it also requires the <code>direction</code> option and the <code>proceed-on</code> values are different.</p> <pre><code>bpfctl load-from-file tc -h\nInstall an eBPF program on the TC hook point for a given interface\nUsage: bpfctl load-from-file --path &lt;PATH&gt; --name &lt;NAME&gt; tc [OPTIONS] --direction &lt;DIRECTION&gt; --iface &lt;IFACE&gt; --priority &lt;PRIORITY&gt;\n------\nOptions:\n--------\n  -d, --direction &lt;DIRECTION&gt;\n          Required: Direction to apply program.\n          [possible values: ingress, egress]\n  -i, --iface &lt;IFACE&gt;\n          Required: Interface to load program on\n  -p, --priority &lt;PRIORITY&gt;\n          Required: Priority to run program in chain. Lower value runs first\n      --proceed-on &lt;PROCEED_ON&gt;...\n          Optional: Proceed to call other programs in chain on this exit code.\n          Multiple values supported by repeating the parameter.\n          Example: --proceed-on \"ok\" --proceed-on \"pipe\"\n          [possible values: unspec, ok, reclassify, shot, pipe, stolen, queued,\n                            repeat, redirect, trap, dispatcher_return]\n          [default: ok, pipe, dispatcher_return]\n  -h, --help\n          Print help (see a summary with '-h')\n</code></pre> <p>The following is an example of the <code>tc</code> command using short option names:</p> <pre><code>bpfctl load-from-file -p /run/bpfd/examples/accept-all.o -n \"accept\" tc -d ingress -i mynet1 -p 40\n</code></pre> <p>For the <code>accept-all.o</code> program loaded with the command above, the name would be set as shown in the following snippet:</p> <pre><code>SEC(\"classifier/accept\")\nint accept(struct __sk_buff *skb)\n{\n</code></pre>"},{"location":"getting-started/bpfctl-guide/#additional-bpfctl-load-examples","title":"Additional bpfctl Load Examples","text":"<p>Below are some additional examples of <code>bpfctl load</code> commands:</p> <p>XDP</p> <pre><code>bpfctl load-from-file --path /run/bpfd/examples/xdp_pass_kern.o --name \"pass\" xdp --iface vethb2795c7 --priority 35\n</code></pre> <p>TC</p> <pre><code>bpfctl load-from-file --path /run/bpfd/examples/filter.bpf.o --name classifier tc --direction ingress --iface vethb2795c7 --priority 110\n</code></pre> <p>Kprobe</p> <pre><code>bpfctl load-from-image --image-url quay.io/bpfd-bytecode/kprobe:latest kprobe -f try_to_wake_up\n</code></pre> <p>Kretprobe</p> <pre><code>bpfctl load-from-image --image-url quay.io/bpfd-bytecode/kretprobe:latest kprobe -f try_to_wake_up -r\n</code></pre> <p>Uprobe</p> <pre><code>bpfctl load-from-image --image-url quay.io/bpfd-bytecode/uprobe:latest uprobe -f \"malloc\" -t \"libc\"\n</code></pre> <p>Uretprobe</p> <pre><code>bpfctl load-from-image --image-url quay.io/bpfd-bytecode/uretprobe:latest uprobe -f \"malloc\" -t \"libc\" -r\n</code></pre>"},{"location":"getting-started/bpfctl-guide/#setting-global-variables-in-ebpf-programs","title":"Setting Global Variables in eBPF Programs","text":"<p>Global variables can be set for any eBPF program type when loading as follows:</p> <pre><code>bpfctl load-from-file -p /run/bpfd/examples/accept-all.o -g GLOBAL_1=01020304 GLOBAL_2=0A0B0C0D -n \"accept\" tc -d ingress -i mynet1 -p 40\n</code></pre> <p>Note, that when setting global variables, the eBPF program being loaded must have global variables named with the strings given, and the size of the value provided must match the size of the given variable.  For example, the above command can be used to update the following global variables in an eBPF program.</p> <pre><code>volatile const __u32 GLOBAL_1 = 0;\nvolatile const __u32 GLOBAL_2 = 0;\n</code></pre>"},{"location":"getting-started/bpfctl-guide/#modifying-the-proceed-on-behavior","title":"Modifying the Proceed-On Behavior","text":"<p>The <code>proceed-on</code> setting applies to <code>xdp</code> and <code>tc</code> programs. For both of these program types, an ordered list of eBPF programs is maintained per attach point. The <code>proceed-on</code> setting determines whether processing will \"proceed\" to the next eBPF program in the list, or terminate processing and return, based on the program's return value. For example, the default <code>proceed-on</code> configuration for an <code>xdp</code> program can be modified as follows:</p> <pre><code>bpfctl load-from-file -p /run/bpfd/examples/xdp_pass_kern.o -n \"xdp\" xdp -i mynet1 -p 30 --proceed-on drop pass dispatcher_return\n</code></pre>"},{"location":"getting-started/bpfctl-guide/#sharing-maps-between-ebpf-programs","title":"Sharing Maps Between eBPF Programs","text":"<p>To share maps between eBPF programs, first load the eBPF program that owns the maps. One eBPF program must own the maps.</p> <pre><code>bpfctl load-from-file --path /run/bpfd/examples/go-xdp-counter/bpf_bpfel.o -n \"xdp_stats\" xdp --iface vethb2795c7 --priority 100\n6371\n</code></pre> <p>Next, load additional eBPF programs that will share the existing maps by passing the program id of the eBPF program that owns the maps using the <code>--map-owner-id</code> parameter:</p> <pre><code>bpfctl load-from-file --path /run/bpfd/examples/go-xdp-counter/bpf_bpfel.o -n \"xdp_stats\" --map-owner-id 6371 xdp --iface vethff657c7 --priority 100\n6373\n</code></pre> <p>Use the <code>bpfctl get &lt;ID&gt;</code> command to display the configuration:</p> <pre><code>bpfctl list\n Program ID  Name       Type  Load Time\n 6371        xdp_stats  xdp   2023-07-18T16:50:46-0400\n 6373        xdp_stats  xdp   2023-07-18T16:51:06-0400\n</code></pre> <pre><code>bpfctl get 6371\n Bpfd State\n---------------\n Name:          xdp_stats\n Path:          /run/bpfd/examples/go-xdp-counter/bpf_bpfel.o\n Global:        None\n Metadata:      None\n Map Pin Path:  /run/bpfd/fs/maps/6371\n Map Owner ID:  None\n Map Used By:   6371\n                6373\n Priority:      50\n Iface:         vethff657c7\n Position:      1\n Proceed On:    pass, dispatcher_return\n:\n</code></pre> <pre><code>bpfctl get 6373\n Bpfd State\n---------------\n Name:          xdp_stats\n Path:          /run/bpfd/examples/go-xdp-counter/bpf_bpfel.o\n Global:        None\n Metadata:      None\n Map Pin Path:  /run/bpfd/fs/maps/6371\n Map Owner ID:  6371\n Map Used By:   6371\n                6373\n Priority:      50\n Iface:         vethff657c7\n Position:      0\n Proceed On:    pass, dispatcher_return\n:\n</code></pre> <p>As the output shows, the first program (<code>6371</code>) owns the map, with <code>Map Owner ID</code> of <code>None</code> and the <code>Map Pin Path</code> (<code>/run/bpfd/fs/maps/6371</code>) that includes its own ID.</p> <p>The second program (<code>6373</code>) references the first program via the <code>Map Owner ID</code> set to <code>6371</code> and the <code>Map Pin Path</code> (<code>/run/bpfd/fs/maps/6371</code>) set to same directory as the first program, which includes the first program's ID. The output for both commands shows the map is being used by both programs via the <code>Map Used By</code> with values of <code>6371</code> and <code>6373</code>.</p> <p>The eBPF programs can be unloaded any order, the <code>Map Pin Path</code> will not be deleted until all the programs referencing the maps are unloaded:</p> <pre><code>bpfctl unload 6371\nbpfctl unload 6373\n</code></pre>"},{"location":"getting-started/bpfctl-guide/#bpfctl-list","title":"bpfctl list","text":"<p>The <code>bpfctl list</code> command lists all the bpfd loaded eBPF programs:</p> <pre><code>bpfctl list\n Program ID  Name              Type        Load Time\n 6201        pass              xdp         2023-07-17T17:17:53-0400\n 6202        sys_enter_openat  tracepoint  2023-07-17T17:19:09-0400\n 6204        stats             tc          2023-07-17T17:20:14-0400\n</code></pre> <p>To see all eBPF programs loaded on the system, include the <code>--all</code> option.</p> <pre><code>bpfctl list --all\n Program ID  Name              Type           Load Time\n 52          restrict_filesy   lsm            2023-05-03T12:53:34-0400\n 166         dump_bpf_map      tracing        2023-05-03T12:53:52-0400\n 167         dump_bpf_prog     tracing        2023-05-03T12:53:52-0400\n 455                           cgroup_device  2023-05-03T12:58:26-0400\n :\n 6190                          cgroup_skb     2023-07-17T17:15:23-0400\n 6191                          cgroup_device  2023-07-17T17:15:23-0400\n 6192                          cgroup_skb     2023-07-17T17:15:23-0400\n 6193                          cgroup_skb     2023-07-17T17:15:23-0400\n 6194                          cgroup_device  2023-07-17T17:15:23-0400\n 6201        pass              xdp            2023-07-17T17:17:53-0400\n 6202        sys_enter_openat  tracepoint     2023-07-17T17:19:09-0400\n 6203        dispatcher        tc             2023-07-17T17:20:14-0400\n 6204        stats             tc             2023-07-17T17:20:14-0400\n 6207        xdp               xdp            2023-07-17T17:27:13-0400\n</code></pre> <p>To filter on a given program type, include the <code>--program-type</code> parameter:</p> <pre><code>bpfctl list --all --program-type tc\n Program ID  Name        Type  Load Time\n 6203        dispatcher  tc    2023-07-17T17:20:14-0400\n 6204        stats       tc    2023-07-17T17:20:14-0400\n</code></pre>"},{"location":"getting-started/bpfctl-guide/#bpfctl-get","title":"bpfctl get","text":"<p>To retrieve detailed information for a loaded eBPF program, use the <code>bpfctl get &lt;ID&gt;</code> command. If the eBPF program was loaded via bpfd, then there will be a <code>Bpfd State</code> section with bpfd related attributes and a <code>Kernel State</code> section with kernel information. If the eBPF program was loaded outside of bpfd, then the <code>Bpfd State</code> section will be empty and <code>Kernel State</code> section will be populated.</p> <pre><code>bpfctl get 6204\n Bpfd State\n---------------\n Name:          stats\n Image URL:     quay.io/bpfd-bytecode/go-tc-counter:latest\n Pull Policy:   IfNotPresent\n Global:        None\n Metadata:      None\n Map Pin Path:  /run/bpfd/fs/maps/6204\n Map Owner ID:  None\n Map Used By:   6204\n Priority:      100\n Iface:         vethff657c7\n Position:      0\n Direction:     eg\n Proceed On:    pipe, dispatcher_return\n Kernel State\n----------------------------------\n ID:                               6204\n Name:                             stats\n Type:                             tc\n Loaded At:                        2023-07-17T17:20:14-0400\n Tag:                              ead94553702a3742\n GPL Compatible:                   true\n Map IDs:                          [2705]\n BTF ID:                           2821\n Size Translated (bytes):          176\n JITed:                            true\n Size JITed (bytes):               116\n Kernel Allocated Memory (bytes):  4096\n Verified Instruction Count:       24\n</code></pre> <pre><code>bpfctl get 6190\n Bpfd State\n---------------\nNONE\n Kernel State\n----------------------------------\nID:                                6190\nName:                              None\nType:                              cgroup_skb\nLoaded At:                         2023-07-17T17:15:23-0400\nTag:                               6deef7357e7b4530\nGPL Compatible:                    true\nMap IDs:                           []\nBTF ID:                            0\nSize Translated (bytes):           64\nJITed:                             true\nSize JITed (bytes):                55\nKernel Allocated Memory (bytes):   4096\nVerified Instruction Count:        8\n</code></pre>"},{"location":"getting-started/bpfctl-guide/#bpfctl-unload","title":"bpfctl unload","text":"<p>The <code>bpfctl unload</code> command takes the program id from the load or list command as a parameter, and unloads the requested eBPF program:</p> <pre><code>bpfctl unload 6204\n</code></pre> <pre><code>bpfctl list\n Program ID  Name              Type        Load Time\n 6201        pass              xdp         2023-07-17T17:17:53-0400\n 6202        sys_enter_openat  tracepoint  2023-07-17T17:19:09-0400\n</code></pre>"},{"location":"getting-started/bpfctl-guide/#bpfctl-pull-bytecode","title":"bpfctl pull-bytecode","text":"<p>The <code>bpfctl pull-bytecode</code> command pulls a given bytecode image for future use by a load command.</p> <pre><code>bpfctl pull-bytecode --help\nPull a bytecode image for future use by a load command\nUsage: bpfctl pull-bytecode [OPTIONS] --image-url &lt;IMAGE_URL&gt;\nOptions:\n  -i, --image-url &lt;IMAGE_URL&gt;\n          Required: Container Image URL.\n          Example: --image-url quay.io/bpfd-bytecode/xdp_pass:latest\n  -r, --registry-auth &lt;REGISTRY_AUTH&gt;\n          Optional: Registry auth for authenticating with the specified image registry.\n          This should be base64 encoded from the '&lt;username&gt;:&lt;password&gt;' string just like\n          it's stored in the docker/podman host config.\n          Example: --registry_auth \"YnjrcKw63PhDcQodiU9hYxQ2\"\n  -p, --pull-policy &lt;PULL_POLICY&gt;\n          Optional: Pull policy for remote images.\n          [possible values: Always, IfNotPresent, Never]\n          [default: IfNotPresent]\n  -h, --help\n          Print help (see a summary with '-h')\n</code></pre> <p>Example usage:</p> <pre><code>bpfctl pull-bytecode --image-url quay.io/bpfd-bytecode/xdp_pass:latest\nSuccessfully downloaded bytecode\n</code></pre> <p>Then when loaded, the local image will be used:</p> <pre><code>bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest --pull-policy IfNotPresent xdp --iface vethff657c7 --priority 100\n Bpfd State                                           \n Name:          pass                                  \n Image URL:     quay.io/bpfd-bytecode/xdp_pass:latest \n Pull Policy:   IfNotPresent                          \n Global:        None                                  \n Metadata:      None                                  \n Map Pin Path:  /run/bpfd/fs/maps/406681              \n Map Owner ID:  None                                  \n Maps Used By:  None                                  \n Priority:      100                                   \n Iface:         vethff657c7                           \n Position:      2                                     \n Proceed On:    pass, dispatcher_return               \n Kernel State                                               \n ID:                               406681                   \n Name:                             pass                     \n Type:                             xdp                      \n Loaded At:                        1917-01-27T01:37:06-0500 \n Tag:                              4b9d1b2c140e87ce         \n GPL Compatible:                   true                     \n Map IDs:                          [736646]                 \n BTF ID:                           555560                   \n Size Translated (bytes):          96                       \n JITted:                           true                     \n Size JITted:                      67                       \n Kernel Allocated Memory (bytes):  4096                     \n Verified Instruction Count:       9                        \n</code></pre>"},{"location":"getting-started/building-bpfd/","title":"Setup and Building bpfd","text":"<p>This section describes how to build bpfd. If this is the first time building bpfd, jump to the Development Environment Setup section for help installing the tooling.</p> <p>There is also an option to run images from a given release as opposed to building locally. Jump to the Run bpfd From Release Image section for installing from a fixed release.</p>"},{"location":"getting-started/building-bpfd/#clone-the-bpfd-repo","title":"Clone the bpfd Repo","text":"<p>You can build and run bpfd from anywhere. However, if you plan to make changes to the bpfd operator, it will need to be under your <code>GOPATH</code> because Kubernetes Code-generator does not work outside of <code>GOPATH</code> issue 86753.  Assuming your <code>GOPATH</code> is set to the typical <code>$HOME/go</code>, your repo should live in <code>$HOME/go/src/github.com/bpfd-dev/bpfd</code></p> <pre><code>mkdir -p $HOME/go/src/github.com/bpfd-dev\ncd $HOME/go/src/github.com/bpfd-dev\ngit clone git@github.com:bpfd-dev/bpfd.git\n</code></pre>"},{"location":"getting-started/building-bpfd/#building-bpfd","title":"Building bpfd","text":"<p>To just test with the latest bpfd, containerized image are stored in <code>quay.io/bpfd</code> (see bpfd Container Images). To build with local changes, use the following commands.</p> <p>If you are building bpfd for the first time OR the eBPF code has changed:</p> <pre><code>cargo xtask build-ebpf --libbpf-dir /path/to/libbpf\n</code></pre> <p>If protobuf files have changed:</p> <pre><code>cargo xtask build-proto\n</code></pre> <p>To build bpfd and bpfctl:</p> <pre><code>cargo build\n</code></pre>"},{"location":"getting-started/building-bpfd/#development-environment-setup","title":"Development Environment Setup","text":"<p>To build bpfd, the following packages must be installed.</p>"},{"location":"getting-started/building-bpfd/#install-rust-toolchain","title":"Install Rust Toolchain","text":"<p>For further detailed instructions, see Rust Stable &amp; Rust Nightly.</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nexport PATH=\"$HOME/.cargo/bin:$PATH\"\nrustup toolchain install nightly -c rustfmt,clippy,rust-src\n</code></pre>"},{"location":"getting-started/building-bpfd/#install-llvm","title":"Install LLVM","text":"<p>LLVM 11 or later must be installed. Linux package managers should provide a recent enough release.</p> <p><code>dnf</code> based OS:</p> <pre><code>sudo dnf install llvm-devel clang-devel elfutils-libelf-devel\n</code></pre> <p><code>apt</code> based OS:</p> <pre><code>sudo apt install clang lldb lld libelf-dev gcc-multilib\n</code></pre>"},{"location":"getting-started/building-bpfd/#install-protobuf-compiler","title":"Install Protobuf Compiler","text":"<p>For further detailed instructions, see protoc.</p> <p><code>dnf</code> based OS:</p> <pre><code>sudo dnf install protobuf-compiler\n</code></pre> <p><code>apt</code> based OS:</p> <pre><code>sudo apt install protobuf-compiler\n</code></pre>"},{"location":"getting-started/building-bpfd/#install-go-protobuf-compiler-extensions","title":"Install GO protobuf Compiler Extensions","text":"<p>See Quick Start Guide for gRPC in Go for installation instructions.</p>"},{"location":"getting-started/building-bpfd/#local-libbpf","title":"Local libbpf","text":"<p>Checkout a local copy of libbpf.</p> <pre><code>git clone https://github.com/libbpf/libbpf --branch v0.8.0\n</code></pre>"},{"location":"getting-started/building-bpfd/#install-perl","title":"Install perl","text":"<p>Install <code>perl</code>:</p> <p><code>dnf</code> based OS:</p> <pre><code>sudo dnf install perl\n</code></pre> <p><code>apt</code> based OS:</p> <pre><code>sudo apt install perl\n</code></pre>"},{"location":"getting-started/example-bpf-k8s/","title":"Deploying Example eBPF Programs On Kubernetes","text":"<p>This section will describe loading bytecode on a Kubernetes cluster and launching the userspace program. The approach is slightly different when running on a Kubernetes cluster. The eBPF bytecode should be loaded by an administrator, not the userspace program itself.</p> <p>This section assumes there is already a Kubernetes cluster running and <code>bpfd</code> is running in the cluster. See Deploying the bpfd-operator for details on deploying bpfd on a Kubernetes cluster, but the quickest solution is to run a Kubernetes KIND Cluster:</p> <pre><code>cd bpfd/bpfd-operator/\nmake run-on-kind\n</code></pre>"},{"location":"getting-started/example-bpf-k8s/#loading-ebpf-bytecode-on-kubernetes","title":"Loading eBPF Bytecode On Kubernetes","text":"<p>Instead of using the userspace program or <code>bpfctl</code> to load the eBPF bytecode as done in previous sections, the bytecode will be loaded by creating a Kubernetes CRD object. There is a CRD object for each eBPF program type bpfd supports. Edit the sample yaml files to customize any configuration values:</p> <ul> <li>TcProgram CRD: go-tc-counter/bytecode.yaml</li> <li>TracepointProgram CRD: go-tracepoint-counter/bytecode.yaml</li> <li>XdpProgram CRD: go-xdp-counter/bytecode.yaml</li> <li>KprobeProgram CRD: bpfd-operator/config/samples/bpfd.io_v1alpha1_kprobe_kprobeprogram.yaml</li> <li>UprobeProgram CRD: bpfd-operator/config/samples/bpfd.io_v1alpha1_uprobe_uprobeprogram.yaml</li> </ul> <p>Sample bytecode yaml with XdpProgram CRD: <pre><code>    vi examples/config/base/go-xdp-counter/bytecode.yaml\n    apiVersion: bpfd.dev/v1alpha1\n    kind: XdpProgram\n    metadata:\n      labels:\n        app.kubernetes.io/name: xdpprogram\n      name: go-xdp-counter-example\n    spec:\n      name: xdp_stats\n      # Select all nodes\n      nodeselector: {}\n      interfaceselector:\n        primarynodeinterface: true\n      priority: 55\n      bytecode:\n        image:\n          url: quay.io/bpfd-bytecode/go-xdp-counter:latest\n</code></pre></p> <p>Note that all the sample yaml files are configured with the bytecode running on all nodes (<code>nodeselector: {}</code>). This can be change to run on specific nodes, but the DaemonSet yaml for the userspace program, which is described below, should have an equivalent change. Make any changes to the <code>go-xdp-counter-bytecode.yaml</code>, then repeat for <code>go-tc-counter-bytecode.yaml</code> and <code>go-tracepoint-counter-bytecode.yaml</code> and then apply the updated yamls:</p> <pre><code>    kubectl apply -f examples/config/base/go-xdp-counter/bytecode.yaml\n     xdpprogram.bpfd.dev/go-xdp-counter-example created\n    kubectl apply -f examples/config/base/go-tc-counter/bytecode.yaml\n     tcprogram.bpfd.dev/go-tc-counter-example created\n    kubectl apply -f examples/config/base/go-tracepoint-counter/bytecode.yaml\n     tracepointprogram.bpfd.dev/go-tracepoint-counter-example created\n</code></pre> <p>Following the diagram for XDP example (Blue numbers):</p> <ol> <li>The user creates a <code>XdpProgram</code> object with the parameters associated with the eBPF bytecode, like interface, priority and BFP bytecode image. The name of the <code>XdpProgram</code> object in this example is <code>go-xdp-counter-example</code>.</li> <li><code>bpfd-agent</code>, running on each node, is watching for all changes to <code>XdpProgram</code> objects. When it sees a <code>XdpProgram</code> object created or modified, it makes sure a <code>BpfProgram</code> object for that node exists. The name of the <code>BpfProgram</code> object is the <code>XdpProgram</code> object name with the node name appended.</li> <li><code>bpfd-agent</code> then determines if it should be running on the given node, loads or unloads as needed by making gRPC calls the <code>bpfd</code>. <code>bpfd</code> behaves the same as described in the running locally example.</li> <li><code>bpfd-agent</code> finally updates the status of the <code>BpfProgram</code> object.</li> <li><code>bpfd-operator</code> watches all <code>BpfProgram</code> objects, and updates the status of the <code>XdpProgram</code> object indicating if the eBPF program has been applied to all the desired nodes or not.</li> </ol> <p>To retrieve information on the <code>XdpProgram</code> objects:</p> <pre><code>    kubectl get xdpprograms\n    NAME                     PRIORITY   DIRECTION\n    go-xdp-counter-example   55\n    kubectl get xdpprograms go-xdp-counter-example -o yaml\n    apiVersion: bpfd.dev/v1alpha1\n    kind: XdpProgram\n    metadata:\n      creationTimestamp: \"2023-05-04T15:41:45Z\"\n      finalizers:\n      - bpfd.dev.operator/finalizer\n      generation: 1\n      labels:\n        app.kubernetes.io/name: xdpprogram\n      name: go-xdp-counter-example\n      resourceVersion: \"1786\"\n      uid: 19a64cf8-3909-4a61-a5c0-5a3ddb95769c\n    spec:\n      bytecode:\n        image:\n          imagepullpolicy: IfNotPresent\n          url: quay.io/bpfd-bytecode/go-xdp-counter:latest\n      interfaceselector:\n        primarynodeinterface: true\n      nodeselector: {}\n      priority: 55\n      proceedon:\n      - pass\n      - dispatcher_return\n      name: xdp_stats\n    status:\n      conditions:\n      - lastTransitionTime: \"2023-05-04T15:41:45Z\"\n        message: Waiting for BpfProgramConfig Object to be reconciled to all nodes\n        reason: ProgramsNotYetLoaded\n        status: \"True\"\n        type: NotYetLoaded\n      - lastTransitionTime: \"2023-05-04T15:41:45Z\"\n        message: bpfProgramReconciliation Succeeded on all nodes\n        reason: ReconcileSuccess\n        status: \"True\"\n        type: ReconcileSuccess\n</code></pre> <p>To retrieve information on the <code>BpfProgram</code> objects:</p> <pre><code>    kubectl get bpfprograms\n    NAME                                                          AGE\n    go-tc-counter-example-bpfd-deployment-control-plane           8m52s\n    go-tc-counter-example-bpfd-deployment-worker                  8m53s\n    go-tc-counter-example-bpfd-deployment-worker2                 8m53s\n    go-tracepoint-counter-example-bpfd-deployment-control-plane   8m52s\n    go-tracepoint-counter-example-bpfd-deployment-worker          8m53s\n    go-tracepoint-counter-example-bpfd-deployment-worker2         8m53s\n    go-xdp-counter-example-bpfd-deployment-control-plane          8m54s\n    go-xdp-counter-example-bpfd-deployment-worker                 8m54s\n    go-xdp-counter-example-bpfd-deployment-worker2                8m54s\n    kubectl get bpfprograms go-xdp-counter-example-bpfd-deployment-worker -o yaml\n    apiVersion: bpfd.dev/v1alpha1\n    kind: BpfProgram\n    metadata:\n      creationTimestamp: \"2023-05-04T15:41:45Z\"\n      finalizers:\n      - bpfd.dev.xdpprogramcontroller-finalizer\n      generation: 2\n      labels:\n        ownedByProgram: go-xdp-counter-example\n      name: go-xdp-counter-example-bpfd-deployment-worker\n      ownerReferences:\n      - apiVersion: bpfd.dev/v1alpha1\n        blockOwnerDeletion: true\n        controller: true\n        kind: XdpProgram\n        name: go-xdp-counter-example\n        uid: 19a64cf8-3909-4a61-a5c0-5a3ddb95769c\n      resourceVersion: \"1869\"\n      uid: 93a0f736-4a7a-48c2-b6ff-bc715b3580d6\n    spec:\n      node: bpfd-deployment-worker\n      programs:\n        ff121084-1211-4fa4-bb16-ddd18e3c63d5:\n          xdp_stats_map: /run/bpfd/fs/maps/ff121084-1211-4fa4-bb16-ddd18e3c63d5/xdp_stats_map\n      type: xdp\n    status:\n      conditions:\n      - lastTransitionTime: \"2023-05-04T15:41:46Z\"\n        message: Successfully loaded bpfProgram\n        reason: bpfdLoaded\n        status: \"True\"\n        type: Loaded\n</code></pre>"},{"location":"getting-started/example-bpf-k8s/#loading-userspace-container-on-kubernetes","title":"Loading Userspace Container On Kubernetes","text":""},{"location":"getting-started/example-bpf-k8s/#loading-a-userspace-container-image","title":"Loading A Userspace Container Image","text":"<p>The userspace programs have been pre-built and can be found here:</p> <ul> <li><code>quay.io/bpfd-userspace/go-tc-counter:latest</code></li> <li><code>quay.io/bpfd-userspace/go-tracepoint-counter:latest</code></li> <li><code>quay.io/bpfd-userspace/go-xdp-counter:latest</code></li> </ul> <p>The example yaml files below are loading from these image.</p> <ul> <li>go-tc-counter/deployment.yaml</li> <li>go-tracepoint-counter/deployment.yaml</li> <li>go-xdp-counter/deployment.yaml</li> </ul> <p>The userspace program in a Kubernetes Deployment no longer interacts directly with <code>bpfd</code>. Instead, the userspace program running on each node reads the <code>BpfProgram</code> to determine the map location. For example, the output above shows the maps as:</p> <pre><code>    kubectl get bpfprograms go-xdp-counter-example-bpfd-deployment-worker -o yaml\n    :\n    spec:\n      node: bpfd-deployment-worker\n      programs:\n        ff121084-1211-4fa4-bb16-ddd18e3c63d5:\n          xdp_stats_map: /run/bpfd/fs/maps/ff121084-1211-4fa4-bb16-ddd18e3c63d5/xdp_stats_map\n      type: xdp\n    :\n</code></pre> <p>To interact with the KubeApiServer, RBAC must be setup properly to access the <code>BpfProgram</code> object. The <code>bpfd-operator</code> defined the yaml for several ClusterRoles that can be used to access the different <code>bpfd</code> related CRD objects with different access rights. The example userspace containers will use the <code>bpfprogram-viewer-role</code>, which allows Read-Only access to the <code>BpfProgram</code> object. This ClusterRole is created automatically by the <code>bpfd-operator</code>.</p> <p>The remaining objects (NameSpace, ServiceAccount, ClusterRoleBinding and examples DaemonSet) also need to be created.</p> <pre><code>    cd bpfd/\n    kubectl create -f examples/config/base/go-xdp-counter/deployment.yaml\n    kubectl create -f examples/config/base/go-tc-counter/deployment.yaml\n    kubectl create -f examples/config/base/go-tracepoint-counter/deployment.yaml\n</code></pre> <p>Following the diagram for the XDP example (Green numbers):</p> <ol> <li>The userspace program queries the KubeApiServer for a specific <code>BpfProgram</code> object.</li> <li>The userspace program pulls the file location of the shared map out of the <code>BpfProgram</code> object and uses the file to periodically read the counter values.</li> </ol> <p>To see if the userspace programs are working, view the logs:</p> <pre><code>    kubectl get pods -A\n    NAMESPACE               NAME                             READY   STATUS    RESTARTS   AGE\n    :\n    go-tc-counter           go-tc-counter-ds-2dfn8           1/1     Running   0          16m\n    go-tc-counter           go-tc-counter-ds-mn82s           1/1     Running   0          16m\n    go-tc-counter           go-tc-counter-ds-qbf9w           1/1     Running   0          16m\n    go-tracepoint-counter   go-tracepoint-counter-ds-686g5   1/1     Running   0          16m\n    go-tracepoint-counter   go-tracepoint-counter-ds-tzj2r   1/1     Running   0          16m\n    go-tracepoint-counter   go-tracepoint-counter-ds-zfz6k   1/1     Running   0          16m\n    go-xdp-counter          go-xdp-counter-ds-c626t          1/1     Running   0          16m\n    go-xdp-counter          go-xdp-counter-ds-kskgh          1/1     Running   0          16m\n    go-xdp-counter          go-xdp-counter-ds-xx6dp          1/1     Running   0          16m\n    :\n    kubectl logs -n go-xdp-counter go-xdp-counter-ds-5q4hz\n    2023/01/08 08:47:55 908748 packets received\n    2023/01/08 08:47:55 631463477 bytes received\n    2023/01/08 08:47:58 908757 packets received\n    2023/01/08 08:47:58 631466099 bytes received\n    2023/01/08 08:48:01 908778 packets received\n    2023/01/08 08:48:01 631472201 bytes received\n    2023/01/08 08:48:04 908791 packets received\n    2023/01/08 08:48:04 631480013 bytes received\n    :\n</code></pre> <p>To cleanup:</p> <pre><code>    kubectl delete -f examples/config/base/go-xdp-counter/deployment.yaml\n    kubectl delete -f examples/config/base/go-xdp-counter/bytecode.yaml\n    kubectl delete -f examples/config/base/go-tc-counter/deployment.yaml\n    kubectl delete -f examples/config/base/go-tc-counter/bytecode.yaml\n    kubectl delete -f examples/config/base/go-tracepoint-counter/deployment.yaml\n    kubectl delete -f examples/config/base/go-tracepoint-counter/bytecode.yaml\n</code></pre>"},{"location":"getting-started/example-bpf-k8s/#automated-deployment","title":"Automated Deployment","text":"<p>The steps above are automated in the <code>Makefile</code> in the examples directory. Run <code>make deploy</code> to load each of the example bytecode and userspace yaml files, then <code>make undeploy</code> to unload them.</p> <pre><code>    cd bpfd/examples/\n    make deploy\n     sed 's@URL_BC@quay.io/bpfd-bytecode/go-tc-counter:latest@' config/default/go-tc-counter/patch.yaml.env &gt; config/default/go-tc-counter/patch.yaml\n     cd config/default/go-tc-counter &amp;&amp; /home/$USER/src/bpfd/examples/bin/kustomize edit set image quay.io/bpfd-userspace/go-tc-counter=quay.io/bpfd-userspace/go-tc-counter:latest\n     /home/$USER/src/bpfd/examples/bin/kustomize build config/default/go-tc-counter | kubectl apply -f -\n     namespace/go-tc-counter created\n     serviceaccount/bpfd-app-go-tc-counter created\n     daemonset.apps/go-tc-counter-ds created\n     tcprogram.bpfd.dev/go-tc-counter-example created\n     sed 's@URL_BC@quay.io/bpfd-bytecode/go-tracepoint-counter:latest@' config/default/go-tracepoint-counter/patch.yaml.env &gt; config/default/go-tracepoint-counter/patch.yaml\n     cd config/default/go-tracepoint-counter &amp;&amp; /home/$USER/src/bpfd/examples/bin/kustomize edit set image quay.io/bpfd-userspace/go-tracepoint-counter=quay.io/bpfd-userspace/go-tracepoint-counter:latest\n     /home/$USER/src/bpfd/examples/bin/kustomize build config/default/go-tracepoint-counter | kubectl apply -f -\n     namespace/go-tracepoint-counter created\n     serviceaccount/bpfd-app-go-tracepoint-counter created\n     clusterrolebinding.rbac.authorization.k8s.io/bpfd-app-rolebinding-go-tracepoint-counter created\n     daemonset.apps/go-tracepoint-counter-ds created\n     tracepointprogram.bpfd.dev/go-tracepoint-counter-example created\n     sed 's@URL_BC@quay.io/bpfd-bytecode/go-xdp-counter:latest@' config/default/go-xdp-counter/patch.yaml.env &gt; config/default/go-xdp-counter/patch.yaml\n     cd config/default/go-xdp-counter &amp;&amp; /home/$USER/src/bpfd/examples/bin/kustomize edit set image quay.io/bpfd-userspace/go-xdp-counter=quay.io/bpfd-userspace/go-xdp-counter:latest\n     /home/$USER/src/bpfd/examples/bin/kustomize build config/default/go-xdp-counter | kubectl apply -f -\n     namespace/go-xdp-counter created\n     serviceaccount/bpfd-app-go-xdp-counter created\n     clusterrolebinding.rbac.authorization.k8s.io/bpfd-app-rolebinding-go-xdp-counter created\n     clusterrolebinding.rbac.authorization.k8s.io/privileged-scc created\n     daemonset.apps/go-xdp-counter-ds created\n     xdpprogram.bpfd.dev/go-xdp-counter-example created\n    # Test Away ...\n\n    make undeploy\n     sed 's@URL_BC@quay.io/bpfd-bytecode/go-tc-counter:latest@' config/default/go-tc-counter/patch.yaml.env &gt; config/default/go-tc-counter/patch.yaml\n     cd config/default/go-tc-counter &amp;&amp; /home/$USER/src/bpfd/examples/bin/kustomize edit set image quay.io/bpfd-userspace/go-tc-counter=quay.io/bpfd-userspace/go-tc-counter:latest\n     /home/$USER/src/bpfd/examples/bin/kustomize build config/default/go-tc-counter | kubectl delete --ignore-not-found=false -f -\n     namespace \"go-tc-counter\" deleted\n     serviceaccount \"bpfd-app-go-tc-counter\" deleted\n     clusterrolebinding.rbac.authorization.k8s.io \"bpfd-app-rolebinding-go-tc-counter\" deleted\n     daemonset.apps \"go-tc-counter-ds\" deleted\n     tcprogram.bpfd.dev \"go-tc-counter-example\" deleted\n     sed 's@URL_BC@quay.io/bpfd-bytecode/go-tracepoint-counter:latest@' config/default/go-tracepoint-counter/patch.yaml.env &gt; config/default/go-tracepoint-counter/patch.yaml\n     cd config/default/go-tracepoint-counter &amp;&amp; /home/$USER/src/bpfd/examples/bin/kustomize edit set image quay.io/bpfd-userspace/go-tracepoint-counter=quay.io/bpfd-userspace/go-tracepoint-counter:latest\n     /home/$USER/src/bpfd/examples/bin/kustomize build config/default/go-tracepoint-counter | kubectl delete --ignore-not-found=false -f -\n     namespace \"go-tracepoint-counter\" deleted\n     serviceaccount \"bpfd-app-go-tracepoint-counter\" deleted\n     clusterrolebinding.rbac.authorization.k8s.io \"bpfd-app-rolebinding-go-tracepoint-counter\" deleted\n     daemonset.apps \"go-tracepoint-counter-ds\" deleted\n     tracepointprogram.bpfd.dev \"go-tracepoint-counter-example\" deleted\n     sed 's@URL_BC@quay.io/bpfd-bytecode/go-xdp-counter:latest@' config/default/go-xdp-counter/patch.yaml.env &gt; config/default/go-xdp-counter/patch.yaml\n     cd config/default/go-xdp-counter &amp;&amp; /home/$USER/src/bpfd/examples/bin/kustomize edit set image quay.io/bpfd-userspace/go-xdp-counter=quay.io/bpfd-userspace/go-xdp-counter:latest\n     /home/$USER/src/bpfd/examples/bin/kustomize build config/default/go-xdp-counter | kubectl delete --ignore-not-found=false -f -\n     namespace \"go-xdp-counter\" deleted\n     serviceaccount \"bpfd-app-go-xdp-counter\" deleted\n     clusterrolebinding.rbac.authorization.k8s.io \"bpfd-app-rolebinding-go-xdp-counter\" deleted\n     clusterrolebinding.rbac.authorization.k8s.io \"privileged-scc\" deleted\n     daemonset.apps \"go-xdp-counter-ds\" deleted\n     xdpprogram.bpfd.dev \"go-xdp-counter-example\" deleted\n</code></pre> <p>Individual examples can be loaded and unloaded as well, for example <code>make deploy-xdp</code> and <code>make undeploy-xdp</code>. To see the full set of available commands, run <code>make help</code>:</p> <pre><code>  make help\n    Usage:\n      make &lt;target&gt;\n      make deploy TAG=v0.2.0\n      make deploy-xdp IMAGE_XDP_US=quay.io/user1/go-xdp-counter-userspace:test\n    General\n      help             Display this help.\n    Local Dependencies\n      kustomize        Download kustomize locally if necessary.\n    Development\n      fmt              Run go fmt against code.\n      verify           Verify all the autogenerated code\n      lint             Run golang-ci linter\n    Build\n      build            Build all the userspace example code.\n      generate         Run `go generate` to build the bytecode for each of the examples.\n      build-us-images  Build all example userspace images\n      push-us-images   Push all example userspace images\n      load-us-images-kind  Build and load all example userspace images into kind\n    Deployment Variables (not commands)\n      TAG              Used to set all images to a fixed tag. Example: make deploy TAG=v0.2.0\n      IMAGE_TC_BC      TC Bytecode image. Example: make deploy-tc IMAGE_TC_BC=quay.io/user1/go-tc-counter-bytecode:test\n      IMAGE_TC_US      TC Userspace image. Example: make deploy-tc IMAGE_TC_US=quay.io/user1/go-tc-counter-userspace:test\n      IMAGE_TP_BC      Tracepoint Bytecode image. Example: make deploy-tracepoint IMAGE_TP_BC=quay.io/user1/go-tracepoint-counter-bytecode:test\n      IMAGE_TP_US      Tracepoint Userspace image. Example: make deploy-tracepoint IMAGE_TP_US=quay.io/user1/go-tracepoint-counter-userspace:test\n      IMAGE_XDP_BC     XDP Bytecode image. Example: make deploy-xdp IMAGE_XDP_BC=quay.io/user1/go-xdp-counter-bytecode:test\n      IMAGE_XDP_US     XDP Userspace image. Example: make deploy-xdp IMAGE_XDP_US=quay.io/user1/go-xdp-counter-userspace:test\n      KIND_CLUSTER_NAME  Name of the deployed cluster to load example images to, defaults to `bpfd-deployment`\n      ignore-not-found  For any undeploy command, set to true to ignore resource not found errors during deletion. Example: make undeploy ignore-not-found=true\n    Deployment\n      deploy-tc        Deploy go-tc-counter to the cluster specified in ~/.kube/config.\n      undeploy-tc      Undeploy go-tc-counter from the cluster specified in ~/.kube/config.\n      deploy-tracepoint  Deploy go-tracepoint-counter to the cluster specified in ~/.kube/config.\n      undeploy-tracepoint  Undeploy go-tracepoint-counter from the cluster specified in ~/.kube/config.\n      deploy-xdp       Deploy go-xdp-counter to the cluster specified in ~/.kube/config.\n      undeploy-xdp     Undeploy go-xdp-counter from the cluster specified in ~/.kube/config.\n      deploy           Deploy all examples to the cluster specified in ~/.kube/config.\n      undeploy         Undeploy all examples to the cluster specified in ~/.kube/config.\n</code></pre>"},{"location":"getting-started/example-bpf-k8s/#building-a-userspace-container-image","title":"Building A Userspace Container Image","text":"<p>To build the userspace examples in a container instead of using the pre-built ones, from the bpfd code source directory (<code>quay.io/bpfd-userspace/</code>), run the following build commands:</p> <pre><code>    cd bpfd/examples\n    make IMAGE_TC_US=quay.io/$USER/go-tc-counter:latest \\\n    IMAGE_TP_US=quay.io/$USER/go-tracepoint-counter:latest \\\n    IMAGE_XDP_US=quay.io/$USER/go-xdp-counter:latest \\\n    build-us-images\n</code></pre> <p>Then EITHER push images to a remote repository:</p> <pre><code>    docker login quay.io\n    cd bpfd/examples\n    make IMAGE_TC_US=quay.io/$USER/go-tc-counter:latest \\\n    IMAGE_TP_US=quay.io/$USER/go-tracepoint-counter:latest \\\n    IMAGE_XDP_US=quay.io/$USER/go-xdp-counter:latest \\\n    push-us-images\n</code></pre> <p>OR load the images directly to a specified kind cluster:</p> <pre><code>    cd bpfd/examples\n    make IMAGE_TC_US=quay.io/$USER/go-tc-counter:latest \\\n    IMAGE_TP_US=quay.io/$USER/go-tracepoint-counter:latest \\\n    IMAGE_XDP_US=quay.io/$USER/go-xdp-counter:latest \\\n    KIND_CLUSTER_NAME=bpfd-deployment \\\n    load-us-images-kind\n</code></pre> <p>Lastly, update the yaml to use the private images or override the yaml files using the Makefile:</p> <pre><code>    cd bpfd/examples/\n    make deploy-xdp IMAGE_XDP_US=quay.io/$USER/go-xdp-counter:latest\n    make undeploy-xdp\n    make deploy-tc IMAGE_TC_US=quay.io/$USER/go-tc-counter:latest\n    make undeploy-tc\n    make deploy-tracepoint IMAGE_TP_US=quay.io/$USER/go-tracepoint-counter:latest\n    make undeploy-tracepoint\n</code></pre>"},{"location":"getting-started/example-bpf-local/","title":"Deploying Example eBPF Programs On Local Host","text":"<p>This section describes running bpfd and the example eBPF programs on a local host. When running bpfd, it can be run as a process or run as a systemd service. Examples run the same, independent of how bpfd is deployed, other than requiring <code>sudo</code> or not.</p> <p>NOTE: When running bpfd as a systemd service, bpfd can only access files owned by the <code>bpfd</code> user, which is created by the install script (<code>./script/setup.sh install</code>). In this case, the install script also copies the examples eBPF bytecode from the examples directory to a directory owned by bpfd (<code>/run/bpfd/examples/</code>). When bpfd is run as a privileged process, the bytecode can be loaded from the examples directory. The example code looks in both locations (<code>/run/bpfd/examples/</code> first), so if the bytecode is recompiled and bpfd is running as a systemd service, run <code>./script/setup.sh examples</code> to update the copied version.</p>"},{"location":"getting-started/example-bpf-local/#building","title":"Building","text":"<p>To build directly on a system, make sure all the prerequisites are met, then build.</p>"},{"location":"getting-started/example-bpf-local/#prerequisites","title":"Prerequisites","text":"<p>This assumes bpfd is already installed and running on the system. If not, see Setup and Building bpfd.</p> <ol> <li>All requirements defined by the <code>cilium/ebpf</code> package</li> <li> <p>libbpf development package to get the required eBPF c headers</p> <p>Fedora:</p> <p><code>sudo dnf install libbpf-devel</code></p> <p>Ubuntu:</p> <p><code>sudo apt-get install libbpf-dev</code></p> </li> <li> <p>Cilium's <code>bpf2go</code> binary</p> <p><code>go install github.com/cilium/ebpf/cmd/bpf2go@master</code></p> </li> </ol>"},{"location":"getting-started/example-bpf-local/#building-locally","title":"Building Locally","text":"<p>To build all the C based eBPF counter bytecode, run:</p> <pre><code>cd bpfd/examples/\nmake generate\n</code></pre> <p>To build all the Userspace GO Client examples, run:</p> <pre><code>cd bpfd/examples/\nmake build\n</code></pre> <p>To build only a single example:</p> <pre><code>cd bpfd/examples/go-tc-counter/\ngo generate\ngo build\n</code></pre> <p><pre><code>cd bpfd/examples/go-tracepoint-counter/\ngo generate\ngo build\n</code></pre> <pre><code>cd bpfd/examples/go-xdp-counter/\ngo generate\ngo build\n</code></pre></p>"},{"location":"getting-started/example-bpf-local/#running-on-host","title":"Running On Host","text":"<p>The most basic way to deploy this example is running directly on a host system. First, start or ensure <code>bpfd</code> is up and running. Tutorial will guide you through deploying <code>bpfd</code>. In all the examples of running on a host system, a bpfd-client certificate is used that is generated by <code>bpfd</code> to encrypt the application's connection to <code>bpfd</code>. The diagram below shows <code>go-xdp-counter</code> example, but the <code>go-tc-counter</code> and <code>go-tracepoint-counter</code> examples operate exactly the same way.</p> <p></p> <p>Following the diagram (Purple numbers):</p> <ol> <li>When <code>go-xdp-counter</code> userspace is started, it will send a gRPC request over mTLS to <code>bpfd</code> requesting <code>bpfd</code> to load the <code>go-xdp-counter</code> eBPF bytecode located on disk at <code>bpfd/examples/go-xdp-counter/bpf_bpfel.o</code> at a priority of 50 and on interface <code>ens3</code>. These values are configurable as we will see later, but for now we will use the defaults (except interface, which is required to be entered).</li> <li><code>bpfd</code> will load it's <code>dispatcher</code> eBPF program, which links to the <code>go-xdp-counter</code> eBPF program and return a UUID referencing the running program.</li> <li><code>bpfctl list</code> can be used to show that the eBPF program was loaded.</li> <li>Once the <code>go-xdp-counter</code> eBPF bytecode is loaded, the eBPF program will write packet counts and byte counts to a shared map.</li> <li><code>go-xdp-counter</code> userspace program periodically reads counters from the shared map and logs the value.</li> </ol>"},{"location":"getting-started/example-bpf-local/#running-privileged","title":"Running Privileged","text":"<p>The most basic example, just use <code>sudo</code> to start the <code>go-xdp-counter</code> program. Determine the host interface to attach the eBPF program to and then start the go program with:</p> <pre><code>cd bpfd/examples/go-xdp-counter/\nsudo ./go-xdp-counter -iface &lt;INTERNET INTERFACE NAME&gt;\n</code></pre> <p>or (NOTE: TC programs also require a direction, ingress or egress)</p> <pre><code>cd bpfd/examples/go-tc-counter/\nsudo ./go-tc-counter -direction ingress -iface &lt;INTERNET INTERFACE NAME&gt;\n</code></pre> <p>or</p> <pre><code>cd bpfd/examples/go-tracepoint-counter/\nsudo ./go-tracepoint-counter\n</code></pre> <p>The output should show the count and total bytes of packets as they pass through the interface as shown below:</p> <pre><code>sudo ./go-xdp-counter --iface vethff657c7\n2023/07/17 17:43:58 Using Input: Interface=vethff657c7 Priority=50 Source=/run/bpfd/examples/go-xdp-counter/bpf_bpfel.o\n2023/07/17 17:43:58 Unable to read /etc/bpfd/bpfd.toml, using default configuration values.\n2023/07/17 17:43:58 Program registered with id 6211\n2023/07/17 17:44:01 4 packets received\n2023/07/17 17:44:01 580 bytes received\n2023/07/17 17:44:04 4 packets received\n2023/07/17 17:44:04 580 bytes received\n2023/07/17 17:44:07 8 packets received\n2023/07/17 17:44:07 1160 bytes received\n:\n</code></pre> <p>Use <code>bpfctl</code> to show the <code>go-xdp-counter</code> eBPF bytecode was loaded.</p> <pre><code>bpfctl list\n Program ID  Name       Type  Load Time\n 6211        xdp_stats  xdp   2023-07-17T17:43:58-0400\n</code></pre> <p>Finally, press <code>&lt;CTRL&gt;+c</code> when finished with <code>go-xdp-counter</code>.</p> <pre><code>:\n2023/07/17 17:44:34 28 packets received\n2023/07/17 17:44:34 4060 bytes received\n^C2023/07/17 17:44:35 Exiting...\n2023/07/17 17:44:35 Unloading Program: 6211\n</code></pre>"},{"location":"getting-started/example-bpf-local/#running-unprivileged","title":"Running Unprivileged","text":"<p>To run the examples unprivileged (without <code>sudo</code>), the following three steps must be performed.</p>"},{"location":"getting-started/example-bpf-local/#step-1-create-bpfd-user-group","title":"Step 1: Create <code>bpfd</code> User Group","text":"<p>The Tutorial guide describes the different modes <code>bpfd</code> can be run in. Specifically, the Systemd Service section explains how to start <code>bpfd</code> and create the <code>bpfd</code> Users and <code>bpfd</code> User Group. <code>bpfd</code> must be started as a Systemd Service and the examples must be run from a User that is a member of the <code>bpfd</code> User Group.</p> <pre><code>sudo usermod -a -G bpfd $USER\nexit\n&lt;LOGIN&gt;\n</code></pre> <p>If the user running the userspace program is not a member of the <code>bpfd</code> user group, then the userspace program cannot access the map files shared between the BFP program and the userspace program. If the above step is skipped, then the userspace program must be run with <code>sudo</code> or the program must be granted CAP_DAC_OVERRIDE capabilities (<code>sudo /sbin/setcap cap_dac_override=ep ./go-xdp-counter</code>).</p>"},{"location":"getting-started/example-bpf-local/#step-2-grant-cap_bpf-linux-capability","title":"Step 2: Grant CAP_BPF Linux Capability","text":"<p>NOTE: Only for kernel versions prior to kernel 5.19</p> <p>The examples use a map to share data between the userspace side of the program and the eBPF portion. Accessing this map requires access to the CAP_BPF capability for kernel versions prior to kernel 5.19. Run the following command to grant <code>go-xdp-counter</code> access to the CAP_BPF capability:</p> <pre><code>cd bpfd/examples/go-xdp-counter/\nsudo /sbin/setcap cap_bpf=ep ./go-xdp-counter\n</code></pre> <p>and</p> <pre><code>cd bpfd/examples/go-tc-counter/\nsudo /sbin/setcap cap_bpf=ep ./go-tc-counter\n</code></pre> <p>and</p> <pre><code>cd bpfd/examples/go-tracepoint-counter/\nsudo /sbin/setcap cap_bpf=ep ./go-tracepoint-counter\n</code></pre> <p>Reminder: The capability must be re-granted each time the examples are rebuilt.</p>"},{"location":"getting-started/example-bpf-local/#step-3-start-go-xdp-counter-without-sudo","title":"Step 3: Start <code>go-xdp-counter</code> without <code>sudo</code>","text":"<p>Start <code>go-xdp-counter</code> without <code>sudo</code>:</p> <pre><code>./go-xdp-counter -iface ens3\n2022/12/02 15:59:34 Unable to read /etc/bpfd/bpfd.toml, using default configuration values.\n2022/12/02 15:59:34 Using Input: Interface=ens3 Priority=50 Source=/run/bpfd/examples/go-xdp-counter/bpf_bpfel.o\n2022/12/02 15:59:35 Program registered with id 6221\n2022/12/02 15:59:38 0 packets received\n2022/12/02 15:59:38 0 bytes received\n2022/12/02 15:59:41 4 packets received\n2022/12/02 15:59:41 580 bytes received\n:\n2022/12/02 16:00:59 64 packets received\n2022/12/02 16:00:59 9280 bytes received\n^C2022/12/02 16:01:00 Exiting...\n2022/12/02 16:01:00 Unloading Program: 6221\n</code></pre>"},{"location":"getting-started/example-bpf-local/#passing-ebpf-bytecode-in-a-container-image","title":"Passing eBPF Bytecode In A Container Image","text":"<p>bpfd can load eBPF bytecode from a container image built following the spec described in eBPF Bytecode Image Specifications. Pre-built eBPF container images for the examples can be loaded from:</p> <ul> <li><code>quay.io/bpfd-bytecode/go-xdp-counter:latest</code></li> <li><code>quay.io/bpfd-bytecode/go-tc-counter:latest</code></li> <li><code>quay.io/bpfd-bytecode/go-tracepoint-counter:latest</code></li> </ul> <p>To use the container image, pass the URL to the userspace program:</p> <pre><code>./go-xdp-counter -iface ens3 -image quay.io/bpfd-bytecode/go-xdp-counter:latest\n2022/12/02 16:28:32 Unable to read /etc/bpfd/bpfd.toml, using default configuration values.\n2022/12/02 16:28:32 Using Input: Interface=ens3 Priority=50 Source=quay.io/bpfd-bytecode/go-xdp-counter:latest\n2022/12/02 16:28:34 Program registered with id 6223\n2022/12/02 16:28:37 4 packets received\n2022/12/02 16:28:37 580 bytes received\n2022/12/02 16:28:40 4 packets received\n2022/12/02 16:28:40 580 bytes received\n^C2022/12/02 16:28:42 Exiting...\n2022/12/02 16:28:42 Unloading Program: 6223\n</code></pre>"},{"location":"getting-started/example-bpf-local/#building-ebpf-bytecode-container-image","title":"Building eBPF Bytecode Container Image","text":"<p>eBPF Bytecode Image Specifications provides detailed instructions on building and shipping bytecode in a container image. To build <code>go-xdp-counter</code> and <code>go-tc-counter</code> eBPF bytecode container image, first make sure the bytecode has been built (i.e. <code>bpf_bpfel.o</code> has been built - see Building), then run the build commands below:</p> <pre><code>cd bpfd/examples/go-xdp-counter/\ngo generate\ndocker build \\\n  --build-arg PROGRAM_NAME=go-xdp-counter \\\n  --build-arg BPF_FUNCTION_NAME=xdp_stats \\\n  --build-arg PROGRAM_TYPE=xdp \\\n  --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\\n  --build-arg KERNEL_COMPILE_VER=$(uname -r) \\\n  -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-xdp-counter-bytecode:latest\n</code></pre> <p>and</p> <pre><code>cd bpfd/examples/go-tc-counter/\ngo generate\ndocker build \\\n  --build-arg PROGRAM_NAME=go-tc-counter \\\n  --build-arg BPF_FUNCTION_NAME=stats \\\n  --build-arg PROGRAM_TYPE=tc \\\n  --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\\n  --build-arg KERNEL_COMPILE_VER=$(uname -r) \\\n  -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-tc-counter-bytecode:latest\n</code></pre> <p>and</p> <pre><code>cd bpfd/examples/go-tracepoint-counter/\ngo generate\ndocker build \\\n  --build-arg PROGRAM_NAME=go-tracepoint-counter \\\n  --build-arg BPF_FUNCTION_NAME=tracepoint_kill_recorder \\\n  --build-arg PROGRAM_TYPE=tracepoint \\\n  --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\\n  --build-arg KERNEL_COMPILE_VER=$(uname -r) \\\n  -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-tracepoint-counter-bytecode:latest\n</code></pre> <p><code>bpfd</code> currently does not provide a method for pre-loading bytecode images (see issue #603), so push the bytecode image to a remote repository. For example:</p> <pre><code>docker login quay.io\ndocker push quay.io/$USER/go-xdp-counter-bytecode:latest\ndocker push quay.io/$USER/go-tc-counter-bytecode:latest\n</code></pre> <p>Then run with the privately built bytecode container image:</p> <pre><code>./go-tc-counter -iface ens3 -direction ingress -location image://quay.io/$USER/go-tc-counter-bytecode:latest\n2022/12/02 16:38:44 Unable to read /etc/bpfd/bpfd.toml, using default configuration values.\n2022/12/02 16:38:44 Using Input: Interface=ens3 Priority=50 Source=quay.io/$USER/go-tc-counter-bytecode:latest\n2022/12/02 16:38:45 Program registered with id 6225\n2022/12/02 16:38:48 4 packets received\n2022/12/02 16:38:48 580 bytes received\n2022/12/02 16:38:51 4 packets received\n2022/12/02 16:38:51 580 bytes received\n^C2022/12/02 16:38:51 Exiting...\n2022/12/02 16:38:51 Unloading Program: 6225\n</code></pre>"},{"location":"getting-started/example-bpf-local/#preloading-ebpf-bytecode","title":"Preloading eBPF Bytecode","text":"<p>Another way to load the eBPF bytecode is to pre-load the eBPF bytecode and pass the associated <code>bpfd</code> program id to the userspace program. This is similar to how eBPF programs will be loaded in Kubernetes, except <code>kubectl</code> commands will be used to create Kubernetes CRD objects instead of using <code>bpfctl</code>, but that is covered in the next section. The userspace programs will skip the loading portion and use the program id to find the shared map and continue from there.</p> <p>Referring back to the diagram above, the <code>load</code> and <code>unload</code> are being done by <code>bpfctl</code> and not <code>go-xdp-counter</code> userspace program.</p> <p>First, use <code>bpfctl</code> to load the <code>go-xdp-counter</code> eBPF bytecode:</p> <pre><code>bpfctl load-from-image --image-url quay.io/bpfd-bytecode/go-xdp-counter:latest xdp --iface ens3 --priority 50\n Bpfd State\n---------------\n Name:          xdp_stats\n Image URL:     quay.io/bpfd-bytecode/go-xdp-counter:latest\n Pull Policy:   IfNotPresent\n Global:        None\n Metadata:      None\n Map Pin Path:  /run/bpfd/fs/maps/6229\n Map Owner ID:  None\n Map Used By:   6229\n Priority:      50\n Iface:         ens3\n Position:      0\n Proceed On:    pass, dispatcher_return\n Kernel State\n----------------------------------\n ID:                               6229\n Name:                             xdp_stats\n Type:                             xdp\n Loaded At:                        2023-07-17T17:48:10-0400\n Tag:                              4b9d1b2c140e87ce\n GPL Compatible:                   true\n Map IDs:                          [2724]\n BTF ID:                           2834\n Size Translated (bytes):          168\n JITed:                            true\n Size JITed (bytes):               104\n Kernel Allocated Memory (bytes):  4096\n Verified Instruction Count:       21\n</code></pre> <p>Then run the <code>go-xdp-counter</code> userspace program, passing in the UUID:</p> <pre><code>./go-xdp-counter -iface ens3 -id 6229\n2022/12/02 17:01:38 Using Input: Interface=ens3 Source=6229\n2022/12/02 17:01:41 180 packets received\n2022/12/02 17:01:41 26100 bytes received\n2022/12/02 17:01:44 184 packets received\n2022/12/02 17:01:44 26680 bytes received\n^C2022/12/02 17:01:46 Exiting...\n2022/12/02 17:01:46 Closing Connection for Program: 6229\n</code></pre> <p>Then use <code>bpfctl</code> to unload the eBPF bytecode:</p> <pre><code>bpfctl unload 6229\n</code></pre>"},{"location":"getting-started/example-bpf/","title":"Example eBPF Programs","text":"<p>Example applications that use the <code>bpfd-go</code> bindings can be found in the examples/ directory. Current examples include:</p> <ul> <li>examples/go-tc-counter/</li> <li>examples/go-tracepoint-counter/</li> <li>examples/go-xdp-counter/</li> </ul> <p>These examples and the associated documentation is intended to provide the basics on how to deploy and manage an eBPF program using bpfd. Each of the examples contain an eBPF Program written in C (tc_counter.c, tracepoint_counter.c and xdp_counter.c) that is compiled into eBPF bytecode. Each time the eBPF program is called, it increments the packet and byte counts in a map that is accessible by the userspace portion.</p> <p>Each of the examples also have a userspace portion written in GO. When run locally, the userspace program makes gRPC calls to <code>bpfd</code> requesting <code>bpfd</code> to load the eBPF program at the requested hook point (XDP hook point, TC hook point or Tracepoint). When run in a Kubernetes deployment, the <code>bpfd-agent</code> makes gRPC calls to <code>bpfd</code> requesting <code>bpfd</code> to load the eBPF program based on a Custom Resource Definition (CRD), which is described in more detail in that section. Independent of the deployment, the userspace program then polls the eBPF map every 3 seconds and logs the current counts. The userspace code is leveraging the cilium/ebpf library to manage the maps shared with the eBPF program. The example eBPF programs are very similar in functionality, and only vary where in the Linux networking stack they are inserted. Read more about XDP and TC programs here.</p> <p>There are two ways to deploy these example applications:</p> <ul> <li>Run locally on one machine: Deploying Example eBPF Programs On Local Host</li> <li>Deploy to multiple nodes in a Kubernetes cluster: Deploying Example eBPF Programs On Kubernetes</li> </ul>"},{"location":"getting-started/example-bpf/#notes","title":"Notes","text":"<p>Notes regarding this document:</p> <ul> <li>Source of images used in the example documentation can be found in   bpfd Upstream Images.   Request access if required.</li> </ul>"},{"location":"getting-started/running-release/","title":"Run bpfd From Release Image","text":"<p>This section describes how to deploy <code>bpfd</code> from a given release. See Releases for the set of bpfd releases.</p> <p>Jump to the Setup and Building bpfd section for help building from the latest code or building from a release branch.</p> <p>Tutorial contains more details on the different modes to run <code>bpfd</code> in on the host and how to test. Use Privileged Mode or Systemd Service below for deploying released version of <code>bpfd</code> and then use Tutorial for further information on how to test and interact with <code>bpfd</code>. </p> <p>Deploying the bpfd-operator contains more details on deploying <code>bpfd</code> in a Kubernetes deployment and Deploying Example eBPF Programs On Kubernetes contains more details on interacting with <code>bpfd</code> running in a Kubernetes deployment. Use Deploying Release Version of the bpfd-operator below for deploying released version of <code>bpfd</code> in Kubernetes and then use the links above for further information on how to test and interact with <code>bpfd</code>. </p>"},{"location":"getting-started/running-release/#privileged-mode","title":"Privileged Mode","text":"<p>To run <code>bpfd</code> in the foreground using <code>sudo</code>, download the release binary tar files and unpack them.</p> <pre><code>export BPFD_REL=0.3.0\nmkdir -p $HOME/src/bpfd-${BPFD_REL}/; cd $HOME/src/bpfd-${BPFD_REL}/\nwget https://github.com/bpfd-dev/bpfd/releases/download/v${BPFD_REL}/bpfctl-linux-x86_64.tar.gz\nwget https://github.com/bpfd-dev/bpfd/releases/download/v${BPFD_REL}/bpfd-linux-x86_64.tar.gz\ntar -xzvf bpfctl-linux-x86_64.tar.gz; rm bpfctl-linux-x86_64.tar.gz\ntar -xzvf bpfd-linux-x86_64.tar.gz; rm bpfd-linux-x86_64.tar.gz\n$ tree\n.\n\u251c\u2500\u2500 bpfctl-linux-x86_64.tar.gz\n\u251c\u2500\u2500 bpfd-linux-x86_64.tar.gz\n\u2514\u2500\u2500 target\n    \u2514\u2500\u2500 x86_64-unknown-linux-musl\n        \u2514\u2500\u2500 release\n            \u251c\u2500\u2500 bpfctl\n            \u2514\u2500\u2500 bpfd\n</code></pre> <p>To deploy <code>bpfd</code>:</p> <pre><code>sudo RUST_LOG=info ./target/x86_64-unknown-linux-musl/release/bpfd \n[2023-10-13T15:53:25Z INFO  bpfd] Log using env_logger\n[2023-10-13T15:53:25Z INFO  bpfd] Has CAP_BPF: true\n[2023-10-13T15:53:25Z INFO  bpfd] Has CAP_SYS_ADMIN: true\n:\n</code></pre> <p>To use <code>bpfctl</code>:</p> <pre><code>sudo ./target/x86_64-unknown-linux-musl/release/bpfctl list\n Program ID  Name       Type  Load Time                \n</code></pre> <p>Continue in Tutorial if desired.</p>"},{"location":"getting-started/running-release/#systemd-service","title":"Systemd Service","text":"<p>To run <code>bpfd</code> as a systemd service, the binaries will be placed in a well known location (<code>/usr/sbin/.</code>) and a service configuration file will be added (<code>/usr/lib/systemd/system/bpfd.service</code>). There is a script that is used to install the service properly, so the source code needs to be downloaded to retrieve the script. Download and unpack the source code, then download and unpack the binaries.</p> <pre><code>export BPFD_REL=0.3.0\nmkdir -p $HOME/src/; cd $HOME/src/\nwget https://github.com/bpfd-dev/bpfd/archive/refs/tags/v${BPFD_REL}.tar.gz\ncd bpfd-${BPFD_REL}\nwget https://github.com/bpfd-dev/bpfd/releases/download/v${BPFD_REL}/bpfctl-linux-x86_64.tar.gz\nwget https://github.com/bpfd-dev/bpfd/releases/download/v${BPFD_REL}/bpfd-linux-x86_64.tar.gz\ntar -xzvf bpfctl-linux-x86_64.tar.gz; rm bpfctl-linux-x86_64.tar.gz\ntar -xzvf bpfd-linux-x86_64.tar.gz; rm bpfd-linux-x86_64.tar.gz\n</code></pre> <p>Run the following command to copy the <code>bpfd</code> and <code>bpfctl</code> binaries to <code>/usr/sbin/</code> and set the user and user group for each, and copy a default <code>bpfd.service</code> file to <code>/usr/lib/systemd/system/</code>. This option will also start the systemd service <code>bpfd.service</code> by default.</p> <pre><code>sudo ./scripts/setup.sh install\n</code></pre> <p>NOTE: If running a release older than <code>v0.3.0</code>, the install script is not coded to copy binaries from the release directory, so the binaries will need to be manually copied.</p> <p>Then add usergroup bpfd to the desired user if not already run and logout/login to apply.</p> <pre><code>sudo usermod -a -G bpfd $USER\nexit\n&lt;LOGIN&gt;\n</code></pre> <p>Continue in Tutorial if desired.</p>"},{"location":"getting-started/running-release/#deploying-release-version-of-the-bpfd-operator","title":"Deploying Release Version of the bpfd-operator","text":"<p>The quickest solution for running <code>bpfd</code> in a Kubernetes deployment is to run a Kubernetes KIND Cluster:</p> <pre><code>kind create cluster --name=test-bpfd\n</code></pre> <p>Next, deploy the bpfd CRDs:</p> <pre><code>export BPFD_REL=0.3.0\nkubectl apply -f  https://github.com/bpfd-dev/bpfd/releases/download/v${BPFD_REL}/bpfd-crds-install-v${BPFD_REL}.yaml\n</code></pre> <p>Next, deploy the <code>bpfd-operator</code>, which will also deploy the <code>bpfd-daemon</code>, which contains <code>bpfd</code> and <code>bpfd-agent</code>:</p> <pre><code>kubectl apply -f https://github.com/bpfd-dev/bpfd/releases/download/v${BPFD_REL}/bpfd-operator-install-v${BPFD_REL}.yaml\n</code></pre> <p>Finally, deploy an example eBPF program.</p> <pre><code>kubectl apply -f https://github.com/bpfd-dev/bpfd/releases/download/v${BPFD_REL}/go-xdp-counter-install-v${BPFD_REL}.yaml\n</code></pre> <p>There are other example programs in the Releases page.</p> <p>Continue in Deploying the bpfd-operator or Deploying Example eBPF Programs On Kubernetes if desired.</p>"},{"location":"getting-started/tutorial/","title":"Tutorial","text":"<p>This tutorial will show you how to use <code>bpfd</code>. There are several ways to launch and interact with <code>bpfd</code> and <code>bpfctl</code>:</p> <ul> <li>Privileged Mode - Run <code>bpfd</code> as a privileged process straight from build directory.   <code>bpfd</code> user is not created so <code>sudo</code> is always required when executing <code>bpfctl</code> commands.   See Privileged Mode.</li> <li>Systemd Service - Run <code>bpfd</code> as a systemd service as the <code>bpfd</code> user.   See Systemd Service.</li> </ul>"},{"location":"getting-started/tutorial/#privileged-mode","title":"Privileged Mode","text":""},{"location":"getting-started/tutorial/#step-1-build-bpfd","title":"Step 1: Build <code>bpfd</code>","text":"<p>Perform the following steps to build <code>bpfd</code>. If this is your first time using bpfd, follow the instructions in Setup and Building bpfd to setup the prerequisites for building.</p> <pre><code>cd $HOME/src/bpfd/\ncargo xtask build-ebpf --libbpf-dir $HOME/src/libbpf\ncargo build\n</code></pre>"},{"location":"getting-started/tutorial/#step-2-setup-bpfd-environment","title":"Step 2: Setup <code>bpfd</code> environment","text":"<p><code>bpfd</code> supports both mTLS for mutual authentication with clients and connecting via a Unix socket. This tutorial will be using <code>bpfctl</code>, which sends gRPC requests to <code>bpfd</code> over a Unix socket. In the Example eBPF Programs, the GO examples use mTLS over TCP to interact with <code>bpfd</code>. If no local certificate authority exists when <code>bpfd</code> is started, <code>bpfd</code> will automatically create the certificate authority in <code>/etc/bpfd/certs/</code>. For this step, no additional actions need to be taken.</p>"},{"location":"getting-started/tutorial/#step-3-start-bpfd","title":"Step 3: Start <code>bpfd</code>","text":"<p>While learning and experimenting with <code>bpfd</code>, it may be useful to run <code>bpfd</code> in the foreground (which requires a second terminal to run the <code>bpfctl</code> commands below). For more details on how logging is handled in bpfd, see Logging.</p> <pre><code>sudo RUST_LOG=info ./target/debug/bpfd\n</code></pre>"},{"location":"getting-started/tutorial/#step-4-load-your-first-program","title":"Step 4: Load your first program","text":"<p>We will load the simple <code>xdp-pass</code> program, which permits all traffic to the attached interface, <code>vethff657c7</code> in this example. The section in the object file that contains the program is \"pass\". Finally, we will use the priority of 100. Find a deeper dive into <code>bpfctl</code> syntax in bpfctl Guide.</p> <pre><code>sudo ./target/debug/bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethff657c7 --priority 100\n Bpfd State\n---------------\n Name:          pass\n Image URL:     quay.io/bpfd-bytecode/xdp_pass:latest\n Pull Policy:   IfNotPresent\n Global:        None\n Metadata:      None\n Map Pin Path:  /run/bpfd/fs/maps/6213\n Map Owner ID:  None\n Map Used By:   6213\n Priority:      100\n Iface:         vethff657c7\n Position:      0\n Proceed On:    pass, dispatcher_return\n Kernel State\n----------------------------------\n ID:                               6213\n Name:                             pass\n Type:                             xdp\n Loaded At:                        2023-07-17T17:48:10-0400\n Tag:                              4b9d1b2c140e87ce\n GPL Compatible:                   true\n Map IDs:                          [2724]\n BTF ID:                           2834\n Size Translated (bytes):          96\n JITed:                            true\n Size JITed (bytes):               67\n Kernel Allocated Memory (bytes):  4096\n Verified Instruction Count:       9\n</code></pre> <p><code>bpfctl load-from-image</code> returns the same data as a <code>bpfctl get</code> command. From the output, the id of <code>6213</code> can be found in the <code>Kernel State</code> section. This id can be used to perform a <code>bpfctl get</code> to retrieve all relevant program data and a <code>bpfctl unload</code> when the program needs to be unloaded.</p> <pre><code>sudo ./target/debug/bpfctl list\n Program ID  Name  Type  Load Time\n 6213        pass  xdp   2023-07-17T17:48:10-0400\n</code></pre> <p>We can recheck the details about the loaded program with the <code>bpfctl get</code> command:</p> <pre><code>sudo ./target/debug/bpfctl get 6213\n Bpfd State\n---------------\n Name:          pass\n Image URL:     quay.io/bpfd-bytecode/xdp_pass:latest\n Pull Policy:   IfNotPresent\n Global:        None\n Metadata:      None\n Map Pin Path:  /run/bpfd/fs/maps/6213\n Map Owner ID:  None\n Map Used By:   6213\n Priority:      100\n Iface:         vethff657c7\n Position:      0\n Proceed On:    pass, dispatcher_return\n Kernel State\n----------------------------------\n ID:                               6213\n Name:                             pass\n Type:                             xdp\n Loaded At:                        2023-07-17T17:48:10-0400\n Tag:                              4b9d1b2c140e87ce\n GPL Compatible:                   true\n Map IDs:                          [2724]\n BTF ID:                           2834\n Size Translated (bytes):          96\n JITed:                            true\n Size JITed (bytes):               67\n Kernel Allocated Memory (bytes):  4096\n Verified Instruction Count:       9\n</code></pre> <p>From the output above you can see the program was loaded to position 0 on our interface and thus will be executed first.</p>"},{"location":"getting-started/tutorial/#step-5-loading-more-programs","title":"Step 5: Loading more programs","text":"<p>We will now load 2 more programs with different priorities to demonstrate how bpfd will ensure they are ordered correctly:</p> <pre><code>sudo ./target/debug/bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethff657c7 --priority 50\n Bpfd State\n---------------\n Name:          pass\n Image URL:     quay.io/bpfd-bytecode/xdp_pass:latest\n Pull Policy:   IfNotPresent\n Global:        None\n Metadata:      None\n Map Pin Path:  /run/bpfd/fs/maps/6215\n Map Owner ID:  None\n Map Used By:   6215\n Priority:      50\n Iface:         vethff657c7\n Position:      0\n Proceed On:    pass, dispatcher_return\n Kernel State\n----------------------------------\n ID:                               6215\n Name:                             pass\n Type:                             xdp\n:\n</code></pre> <pre><code>sudo ./target/debug/bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethff657c7 --priority 200\n Bpfd State\n---------------\n Name:          pass\n Image URL:     quay.io/bpfd-bytecode/xdp_pass:latest\n Pull Policy:   IfNotPresent\n Global:        None\n Metadata:      None\n Map Pin Path:  /run/bpfd/fs/maps/6217\n Map Owner ID:  None\n Map Used By:   6217\n Priority:      200\n Iface:         vethff657c7\n Position:      2\n Proceed On:    pass, dispatcher_return\n Kernel State\n----------------------------------\n ID:                               6217\n Name:                             pass\n Type:                             xdp\n:\n</code></pre> <p>Using <code>bpfctl list</code> we can see all the programs that were loaded.</p> <pre><code>sudo ./target/debug/bpfctl list\n Program ID  Name  Type  Load Time\n 6213        pass  xdp   2023-07-17T17:48:10-0400\n 6215        pass  xdp   2023-07-17T17:52:46-0400\n 6217        pass  xdp   2023-07-17T17:53:57-0400\n</code></pre> <p>The lowest priority program is executed first, while the highest is executed last. As can be seen from the detailed output for each command below:</p> <ul> <li>Program <code>6215</code> is at position <code>0</code> with a priority of <code>50</code></li> <li>Program <code>6213</code> is at position <code>1</code> with a priority of <code>100</code></li> <li>Program <code>6217</code> is at position <code>2</code> with a priority of <code>200</code></li> </ul> <pre><code>sudo ./target/debug/bpfctl get 6213\n Bpfd State\n---------------\n Name:          pass\n:\n Priority:      100\n Iface:         vethff657c7\n Position:      1\n Proceed On:    pass, dispatcher_return\n Kernel State\n----------------------------------\n ID:                               6213\n Name:                             pass\n Type:                             xdp\n:\n</code></pre> <pre><code>sudo ./target/debug/bpfctl get 6215\n Bpfd State\n---------------\n Name:          pass\n:\n Priority:      50\n Iface:         vethff657c7\n Position:      0\n Proceed On:    pass, dispatcher_return\n Kernel State\n----------------------------------\n ID:                               6215\n Name:                             pass\n Type:                             xdp\n:\n</code></pre> <pre><code>sudo ./target/debug/bpfctl get 6217\n Bpfd State\n---------------\n Name:          pass\n:\n Priority:      200\n Iface:         vethff657c7\n Position:      2\n Proceed On:    pass, dispatcher_return\n Kernel State\n----------------------------------\n ID:                               6217\n Name:                             pass\n Type:                             xdp\n:\n</code></pre> <p>By default, the next program in the chain will only be executed if a given program returns <code>pass</code> (see <code>proceed-on</code> field in the <code>bpfctl get</code> output above). If the next program in the chain should be called even if a different value is returned, then the program can be loaded with those additional return values using the <code>proceed-on</code> parameter (see <code>bpfctl load-from-image xdp --help</code> for list of valid values):</p> <pre><code>sudo ./target/debug/bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethff657c7 --priority 150 --proceed-on \"pass\" --proceed-on \"dispatcher_return\"\n Bpfd State\n---------------\n Name:          pass\n Image URL:     quay.io/bpfd-bytecode/xdp_pass:latest\n Pull Policy:   IfNotPresent\n Global:        None\n Metadata:      None\n Map Pin Path:  /run/bpfd/fs/maps/6219\n Map Owner ID:  None\n Map Used By:   6219\n Priority:      150\n Iface:         vethff657c7\n Position:      2\n Proceed On:    pass, dispatcher_return\n Kernel State\n----------------------------------\n ID:                               6219\n Name:                             pass\n Type:                             xdp\n:\n</code></pre> <p>Which results in being loaded in position <code>2</code> because it was loaded at priority <code>150</code>, which is lower than the previous program at that position with a priority of <code>200</code>.</p>"},{"location":"getting-started/tutorial/#step-6-delete-a-program","title":"Step 6: Delete a program","text":"<p>Let's remove the program at position 1.</p> <pre><code>sudo ./target/debug/bpfctl list\n Program ID  Name  Type  Load Time\n 6213        pass  xdp   2023-07-17T17:48:10-0400\n 6215        pass  xdp   2023-07-17T17:52:46-0400\n 6217        pass  xdp   2023-07-17T17:53:57-0400\n 6219        pass  xdp   2023-07-17T17:59:41-0400\n</code></pre> <pre><code>sudo ./target/debug/bpfctl unload 6213\n</code></pre> <p>And we can verify that it has been removed and the other programs re-ordered:</p> <pre><code>sudo ./target/debug/bpfctl list\n Program ID  Name  Type  Load Time\n 6215        pass  xdp   2023-07-17T17:52:46-0400\n 6217        pass  xdp   2023-07-17T17:53:57-0400\n 6219        pass  xdp   2023-07-17T17:59:41-0400\n</code></pre> <pre><code>./target/debug/bpfctl get 6215\n Bpfd State\n---------------\n Name:          pass\n Image URL:     quay.io/bpfd-bytecode/xdp_pass:latest\n Pull Policy:   IfNotPresent\n Global:        None\n Metadata:      None\n Map Pin Path:  /run/bpfd/fs/maps/6215\n Map Owner ID:  None\n Map Used By:   6215\n Priority:      50\n Iface:         vethff657c7\n Position:      0\n Proceed On:    pass, dispatcher_return\n Kernel State\n----------------------------------\n ID:                               6215\n Name:                             pass\n Type:                             xdp\n:\n</code></pre> <pre><code>./target/debug/bpfctl get 6217\n Bpfd State\n---------------\n Name:          pass\n Image URL:     quay.io/bpfd-bytecode/xdp_pass:latest\n Pull Policy:   IfNotPresent\n Global:        None\n Metadata:      None\n Map Pin Path:  /run/bpfd/fs/maps/6217\n Map Owner ID:  None\n Map Used By:   6217\n Priority:      200\n Iface:         vethff657c7\n Position:      2\n Proceed On:    pass, dispatcher_return\n\n Kernel State\n----------------------------------\n ID:                               6217\n Name:                             pass\n Type:                             xdp\n:\n</code></pre> <pre><code>./target/debug/bpfctl get 6219\n Bpfd State\n---------------\n Name:          pass\n Image URL:     quay.io/bpfd-bytecode/xdp_pass:latest\n Pull Policy:   IfNotPresent\n Global:        None\n Metadata:      None\n Map Pin Path:  /run/bpfd/fs/maps/6219\n Map Owner ID:  None\n Map Used By:   6219\n Priority:      150\n Iface:         vethff657c7\n Position:      1\n Proceed On:    pass, dispatcher_return\n\n Kernel State\n----------------------------------\n ID:                               6219\n Name:                             pass\n Type:                             xdp\n:\n</code></pre> <p>When <code>bpfd</code> is stopped, all remaining programs will be unloaded automatically.</p>"},{"location":"getting-started/tutorial/#step-7-clean-up","title":"Step 7: Clean-up","text":"<p>To unwind all the changes, stop <code>bpfd</code> and then run the following script:</p> <pre><code>sudo ./scripts/setup.sh uninstall\n</code></pre> <p>WARNING: <code>setup.sh uninstall</code> cleans everything up, so <code>/etc/bpfd/programs.d/</code> and <code>/run/bpfd/bytecode/</code> are deleted. Save any changes or files that were created if needed.</p>"},{"location":"getting-started/tutorial/#systemd-service","title":"Systemd Service","text":"<p>To run <code>bpfd</code> as a systemd service, the binaries will be placed in a well known location (<code>/usr/sbin/.</code>) and a service configuration file will be added (<code>/usr/lib/systemd/system/bpfd.service</code>). When run as a systemd service, the set of linux capabilities are limited to only the needed set. If permission errors are encountered, see Linux Capabilities for help debugging.</p>"},{"location":"getting-started/tutorial/#step-1","title":"Step 1","text":"<p>Same as Step 1 above, build <code>bpfd</code> if needed:</p> <pre><code>cd $HOME/src/bpfd/\ncargo xtask build-ebpf --libbpf-dir $HOME/src/libbpf\ncargo build\n</code></pre>"},{"location":"getting-started/tutorial/#step-2-setup-bpfd-environment_1","title":"Step 2: Setup <code>bpfd</code> environment","text":"<p>Run the following command to copy the <code>bpfd</code> and <code>bpfctl</code> binaries to <code>/usr/sbin/</code> and set the user and user group for each, and copy a default <code>bpfd.service</code> file to <code>/usr/lib/systemd/system/</code>. This option will also start the systemd service <code>bpfd.service</code> by default:</p> <pre><code>sudo ./scripts/setup.sh install\n</code></pre> <p>Then add usergroup <code>bpfd</code> to the desired user if not already run and logout/login to apply. Programs run by users which are members of the <code>bpfd</code> user group are able to access the mTLS certificates created by bpfd. Therefore, these programs can make bpfd requests without requiring <code>sudo</code>. For userspace programs accessing maps, the maps are owned by the <code>bpfd</code> user and <code>bpfd</code> user group. Programs run by users which are members of the <code>bpfd</code> user group are able to access the maps files without requiring  <code>sudo</code> (specifically CAP_DAC_SEARCH or CAP_DAC_OVERIDE).</p> <pre><code>sudo usermod -a -G bpfd $USER\nexit\n&lt;LOGIN&gt;\n</code></pre> <p>NOTE: Prior to kernel 5.19, all eBPF sys calls required CAP_BPF, which are used to access maps shared between the BFP program and the userspace program. So userspace programs that are accessing maps and running on kernels older than 5.19 will require either <code>sudo</code> or the CAP_BPF capability (<code>sudo /sbin/setcap cap_bpf=ep ./&lt;USERSPACE-PROGRAM&gt;</code>).</p> <p>To update the configuration settings associated with running <code>bpfd</code> as a service, edit the service configuration file:</p> <pre><code>sudo vi /usr/lib/systemd/system/bpfd.service\nsudo systemctl daemon-reload\n</code></pre> <p>If <code>bpfd</code> or <code>bpfctl</code> is rebuilt, the following command can be run to install the update binaries without tearing down the users and regenerating the certifications. The <code>bpfd</code> service will is automatically restarted.</p> <pre><code>sudo ./scripts/setup.sh reinstall\n</code></pre>"},{"location":"getting-started/tutorial/#step-3-start-bpfd_1","title":"Step 3: Start <code>bpfd</code>","text":"<p>To manage <code>bpfd</code> as a systemd service, use <code>systemctl</code>. <code>sudo ./scripts/setup.sh install</code> will start the service, but the service can be manually stopped and started:</p> <pre><code>sudo systemctl stop bpfd.service\n...\nsudo systemctl start bpfd.service\n</code></pre>"},{"location":"getting-started/tutorial/#step-4-6","title":"Step 4-6","text":"<p>Same as above except <code>sudo</code> can be dropped from all the <code>bpfctl</code> commands and <code>bpfctl</code> is now in $PATH:</p> <pre><code>bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethff657c7 --priority 100\n:\nbpfctl list\n Program ID  Name  Type  Load Time\n 6213        pass  xdp   2023-07-17T17:48:10-0400\nbpfctl unload 6213\n</code></pre>"},{"location":"getting-started/tutorial/#step-7-clean-up_1","title":"Step 7: Clean-up","text":"<p>To unwind all the changes performed while running <code>bpfd</code> as a systemd service, run the following script. This command cleans up everything, including stopping the <code>bpfd</code> service if it is still running.</p> <pre><code>sudo ./scripts/setup.sh uninstall\n</code></pre> <p>WARNING: <code>setup.sh uninstall</code> cleans everything up, so <code>/etc/bpfd/programs.d/</code> and <code>/run/bpfd/bytecode/</code> are deleted. Save any changes or files that were created if needed.</p>"},{"location":"getting-started/tutorial/#build-and-run-local-ebpf-programs","title":"Build and Run Local eBPF Programs","text":"<p>In the examples above, all the eBPF programs were pulled from pre-built images. This tutorial uses examples from the xdp-tutorial. The pre-built container images can be found here: https://quay.io/organization/bpfd-bytecode</p> <p>To build these examples locally, check out the xdp-tutorial git repository and compile the examples. eBPF Bytecode Image Specifications describes how eBPF bytecode ispackaged in container images.</p> <p>To load these programs locally, use the <code>bpfctl load-from-file</code> command in place of the <code>bpfctl load-from-image</code> command. For example:</p> <pre><code>sudo ./target/debug/bpfctl load-from-file --path /$HOME/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o --name \"pass\" xdp --iface vethff657c7 --priority 100\n</code></pre>"},{"location":"governance/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"governance/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"governance/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"governance/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"governance/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"governance/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement directly. Maintainers are identified in the MAINTAINERS.md file and their contact information is on their GitHub profile page. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"governance/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"governance/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"governance/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"governance/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"governance/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"governance/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"governance/CONTRIBUTING/","title":"Contributing Guide","text":"<ul> <li>New Contributor Guide</li> <li>Ways to Contribute</li> <li>Find an Issue</li> <li>Ask for Help</li> <li>Pull Request Lifecycle</li> <li>Development Environment Setup</li> <li>Signoff Your Commits</li> <li>Pull Request Checklist</li> </ul> <p>Welcome! We are glad that you want to contribute to our project! \ud83d\udc96</p> <p>As you get started, you are in the best position to give us feedback on areas of our project that we need help with including:</p> <ul> <li>Problems found during setting up a new developer environment</li> <li>Gaps in our Quickstart Guide or documentation</li> <li>Bugs in our automation scripts</li> </ul> <p>If anything doesn't make sense, or doesn't work when you run it, please open a bug report and let us know!</p>"},{"location":"governance/CONTRIBUTING/#ways-to-contribute","title":"Ways to Contribute","text":"<p>We welcome many different types of contributions including:</p> <ul> <li>New features</li> <li>Builds, CI/CD</li> <li>Bug fixes</li> <li>Documentation</li> <li>Issue Triage</li> <li>Answering questions on Slack/Mailing List</li> <li>Web design</li> <li>Communications / Social Media / Blog Posts</li> <li>Release management</li> </ul> <p>Not everything happens through a GitHub pull request. Please come to our meetings or contact us and let's discuss how we can work together.</p>"},{"location":"governance/CONTRIBUTING/#come-to-meetings","title":"Come to Meetings","text":"<p>Absolutely everyone is welcome to come to any of our meetings. You never need an invite to join us. In fact, we want you to join us, even if you don\u2019t have anything you feel like you want to contribute. Just being there is enough!</p> <p>You can find out more about our meetings here. You don\u2019t have to turn on your video. The first time you come, introducing yourself is more than enough. Over time, we hope that you feel comfortable voicing your opinions, giving feedback on others\u2019 ideas, and even sharing your own ideas, and experiences.</p>"},{"location":"governance/CONTRIBUTING/#find-an-issue","title":"Find an Issue","text":"<p>We have good first issues for new contributors and help wanted issues suitable for any contributor. good first issue has extra information to help you make your first contribution. help wanted are issues suitable for someone who isn't a core maintainer and is good to move onto after your first pull request.</p> <p>Sometimes there won\u2019t be any issues with these labels. That\u2019s ok! There is likely still something for you to work on. If you want to contribute but you don\u2019t know where to start or can't find a suitable issue, you can reach out to us on Slack and we will be happy to help.</p> <p>Once you see an issue that you'd like to work on, please post a comment saying that you want to work on it. Something like \"I want to work on this\" is fine.</p>"},{"location":"governance/CONTRIBUTING/#ask-for-help","title":"Ask for Help","text":"<p>The best way to reach us with a question when contributing is to ask on:</p> <ul> <li>The original github issue</li> <li>Our Slack channel</li> </ul>"},{"location":"governance/CONTRIBUTING/#pull-request-lifecycle","title":"Pull Request Lifecycle","text":"<p>Pull requests are managed by Mergify.</p> <p>Our process is currently as follows:</p> <ol> <li>When you open a PR a maintainer will automatically be assigned for review</li> <li>Make sure that your PR is passing CI - if you need help with failing checks please feel free to ask!</li> <li>Once it is passing all CI checks, a maintainer will review your PR and you may be asked to make changes.</li> <li>When you have received at least one approval from a maintainer, your PR will be merged automiatcally.</li> </ol> <p>In some cases, other changes may conflict with your PR. If this happens, you will get notified by a comment in the issue that your PR requires a rebase, and the <code>needs-rebase</code> label will be applied. Once a rebase has been performed, this label will be automatically removed.</p>"},{"location":"governance/CONTRIBUTING/#development-environment-setup","title":"Development Environment Setup","text":"<p>Instructions</p>"},{"location":"governance/CONTRIBUTING/#signoff-your-commits","title":"Signoff Your Commits","text":""},{"location":"governance/CONTRIBUTING/#dco","title":"DCO","text":"<p>Licensing is important to open source projects. It provides some assurances that the software will continue to be available based under the terms that the author(s) desired. We require that contributors sign off on commits submitted to our project's repositories. The Developer Certificate of Origin (DCO) is a way to certify that you wrote and have the right to contribute the code you are submitting to the project.</p> <p>You sign-off by adding the following to your commit messages. Your sign-off must match the git user and email associated with the commit.</p> <pre><code>This is my commit message\n\nSigned-off-by: Your Name &lt;your.name@example.com&gt;\n</code></pre> <p>Git has a <code>-s</code> command line option to do this automatically:</p> <pre><code>git commit -s -m 'This is my commit message'\n</code></pre> <p>If you forgot to do this and have not yet pushed your changes to the remote repository, you can amend your commit with the sign-off by running</p> <pre><code>git commit --amend -s\n</code></pre>"},{"location":"governance/CONTRIBUTING/#logical-grouping-of-commits","title":"Logical Grouping of Commits","text":"<p>It is a recommended best practice to keep your changes as logically grouped as possible within individual commits. If while you're developing you prefer doing a number of commits that are \"checkpoints\" and don't represent a single logical change, please squash those together before asking for a review. When addressing review comments, please perform an interactive rebase and edit commits directly rather than adding new commits with messages like \"Fix review comments\".</p>"},{"location":"governance/CONTRIBUTING/#commit-message-guidelines","title":"Commit message guidelines","text":"<p>A good commit message should describe what changed and why.</p> <ol> <li> <p>The first line should:</p> </li> <li> <p>contain a short description of the change (preferably 50 characters or less,     and no more than 72 characters)</p> </li> <li>be entirely in lowercase with the exception of proper nouns, acronyms, and     the words that refer to code, like function/variable names</li> <li>be prefixed with the name of the sub crate being changed</li> </ol> <p>Examples:</p> <pre><code>* bpfd: validate program section names\n* bpf: add dispatcher program test slot\n</code></pre> <ol> <li>Keep the second line blank.</li> <li>Wrap all other lines at 72 columns (except for long URLs).</li> <li>If your patch fixes an open issue, you can add a reference to it at the end    of the log. Use the <code>Fixes: #</code> prefix and the issue number. For other    references use <code>Refs: #</code>. <code>Refs</code> may include multiple issues, separated by a    comma.</li> </ol> <p>Examples:</p> <ul> <li><code>Fixes: #1337</code></li> <li><code>Refs: #1234</code></li> </ul> <p>Sample complete commit message:</p> <pre><code>subcrate: explain the commit in one line\n\nBody of commit message is a few lines of text, explaining things\nin more detail, possibly giving some background about the issue\nbeing fixed, etc.\n\nThe body of the commit message can be several paragraphs, and\nplease do proper word-wrap and keep columns shorter than about\n72 characters or so. That way, `git log` will show things\nnicely even when it is indented.\n\nFixes: #1337\nRefs: #453, #154\n</code></pre>"},{"location":"governance/CONTRIBUTING/#pull-request-checklist","title":"Pull Request Checklist","text":"<p>When you submit your pull request, or you push new commits to it, our automated systems will run some checks on your new code. We require that your pull request passes these checks, but we also have more criteria than just that before we can accept and merge it. We recommend that you check the following things locally before you submit your code:</p> <ul> <li>That Rust code has been formatted with <code>cargo +nightly fmt</code> and that all clippy lints have been fixed - you can find failing lints with <code>cargo +nightly clippy</code></li> <li>That Go code has been formatted and linted</li> <li>That unit tests are passing locally with <code>cargo test</code></li> <li>That integration tests are passing locally <code>cargo xtask integration-test</code></li> </ul>"},{"location":"governance/GOVERNANCE/","title":"bpfd Project Governance","text":"<p>The bpfd project is dedicated to creating an easy way to run eBPF programs on a single host and in clusters. This governance explains how the project is run.</p> <ul> <li>Values</li> <li>Maintainers</li> <li>Becoming a Maintainer</li> <li>Meetings</li> <li>Code of Conduct Enforcement</li> <li>Security Response Team</li> <li>Voting</li> <li>Modifications</li> </ul>"},{"location":"governance/GOVERNANCE/#values","title":"Values","text":"<p>The bpfd project and its leadership embrace the following values:</p> <ul> <li> <p>Openness: Communication and decision-making happens in the open and is discoverable for future   reference. As much as possible, all discussions and work take place in public   forums and open repositories.</p> </li> <li> <p>Fairness: All stakeholders have the opportunity to provide feedback and submit   contributions, which will be considered on their merits.</p> </li> <li> <p>Community over Product or Company: Sustaining and growing our community takes   priority over shipping code or sponsors' organizational goals.  Each   contributor participates in the project as an individual.</p> </li> <li> <p>Inclusivity: We innovate through different perspectives and skill sets, which   can only be accomplished in a welcoming and respectful environment.</p> </li> <li> <p>Participation: Responsibilities within the project are earned through   participation, and there is a clear path up the contributor ladder into leadership   positions.</p> </li> </ul>"},{"location":"governance/GOVERNANCE/#maintainers","title":"Maintainers","text":"<p>bpfd Maintainers have write access to the project GitHub repository. They can merge their patches or patches from others. The list of current maintainers can be found at MAINTAINERS.md.  Maintainers collectively manage the project's resources and contributors.</p> <p>This privilege is granted with some expectation of responsibility: maintainers are people who care about the bpfd project and want to help it grow and improve. A maintainer is not just someone who can make changes, but someone who has demonstrated their ability to collaborate with the team, get the most knowledgeable people to review code and docs, contribute high-quality code, and follow through to fix issues (in code or tests).</p> <p>A maintainer is a contributor to the project's success and a citizen helping the project succeed.</p> <p>The collective team of all Maintainers is known as the Maintainer Council, which is the governing body for the project.</p>"},{"location":"governance/GOVERNANCE/#becoming-a-maintainer","title":"Becoming a Maintainer","text":"<p>To become a Maintainer you need to demonstrate the following:</p> <ul> <li>commitment to the project:</li> <li>participate in discussions, contributions, code and documentation reviews, for 6 months or more,</li> <li>perform reviews for 10 non-trivial pull requests,</li> <li>contribute 10 non-trivial pull requests and have them merged,</li> <li>ability to write quality code and/or documentation,</li> <li>ability to collaborate with the team,</li> <li>understanding of how the team works (policies, processes for testing and code review, etc),</li> <li>understanding of the project's code base and coding and documentation style.</li> </ul> <p>A new Maintainer must be proposed by an existing maintainer by opening a Pull Request on GitHub to update the MAINTAINERS.md file. A simple majority vote of existing Maintainers approves the application. Maintainer nominations will be evaluated without prejudice to employers or demographics.</p> <p>Maintainers who are selected will be granted the necessary GitHub rights.</p>"},{"location":"governance/GOVERNANCE/#removing-a-maintainer","title":"Removing a Maintainer","text":"<p>Maintainers may resign at any time if they feel that they will not be able to continue fulfilling their project duties.</p> <p>Maintainers may also be removed after being inactive, failing to fulfill their Maintainer responsibilities, violating the Code of Conduct, or for other reasons. Inactivity is defined as a period of very low or no activity in the project for a year or more, with no definite schedule to return to full Maintainer activity.</p> <p>A Maintainer may be removed at any time by a 2/3 vote of the remaining maintainers.</p> <p>Depending on the reason for removal, a Maintainer may be converted to Emeritus status. Emeritus Maintainers will still be consulted on some project matters and can be rapidly returned to Maintainer status if their availability changes.</p>"},{"location":"governance/GOVERNANCE/#meetings","title":"Meetings","text":"<p>Time zones permitting, Maintainers are expected to participate in the public developer meeting, detailed in the meetings document.</p> <p>Maintainers will also have closed meetings to discuss security reports or Code of Conduct violations. Such meetings should be scheduled by any Maintainer on receipt of a security issue or CoC report. All current Maintainers must be invited to such closed meetings, except for any Maintainer who is accused of a CoC violation.</p>"},{"location":"governance/GOVERNANCE/#code-of-conduct","title":"Code of Conduct","text":"<p>Code of Conduct violations by community members will be discussed and resolved on the private maintainer Slack channel.</p>"},{"location":"governance/GOVERNANCE/#security-response-team","title":"Security Response Team","text":"<p>The Maintainers will appoint a Security Response Team to handle security reports. This committee may simply consist of the Maintainer Council themselves.  If this responsibility is delegated, the Maintainers will appoint a team of at least two contributors to handle it.  The Maintainers will review who is assigned to this at least once a year.</p> <p>The Security Response Team is responsible for handling all reports of security holes and breaches according to the security policy.</p>"},{"location":"governance/GOVERNANCE/#voting","title":"Voting","text":"<p>While most business in bpfd is conducted by \"lazy consensus\", periodically the Maintainers may need to vote on specific actions or changes. A vote can be taken on the private developer slack channel for security or conduct matters. Votes may also be taken at the developer meeting.  Any Maintainer may demand a vote be taken.</p> <p>Most votes require a simple majority of all Maintainers to succeed, except where otherwise noted.  Two-thirds majority votes mean at least two-thirds of all existing maintainers.</p>"},{"location":"governance/GOVERNANCE/#modifying-this-charter","title":"Modifying this Charter","text":"<p>Changes to this Governance and its supporting documents may be approved by a 2/3 vote of the Maintainers.</p>"},{"location":"governance/MAINTAINERS/","title":"Maintainers","text":"<p>See CONTRIBUTING.md for general contribution guidelines. See GOVERNANCE.md for governance guidelines and maintainer responsibilities. See CODEOWNERS for a detailed list of owners for the various source directories.</p> Name Employer Responsibilities Dave Tucker Red Hat Catch all Andrew Stoycos Red Hat bpfd-operator, bpfd-agent Andre Fredette Red Hat All things tc-bpf Billy McFall Red Hat All things systemd"},{"location":"governance/MEETINGS/","title":"bpfd Community Meetings","text":""},{"location":"governance/MEETINGS/#meeting-time","title":"Meeting time","text":"<p>We meet every Thursday at 10:00 AM Eastern Time. The meetings last up to 1 hour.</p>"},{"location":"governance/MEETINGS/#meeting-location","title":"Meeting location","text":"<p>Video call link: https://meet.google.com/ggz-zkmp-pxx Or dial: (US) +1 98ttp4-221-0859 PIN: 613 588 790# More phone numbers: https://tel.meet/ggz-zkmp-pxx?pin=3270510926446</p>"},{"location":"governance/MEETINGS/#meeting-agenda-and-minutes","title":"Meeting agenda and minutes","text":"<p>Meeting agenda</p>"},{"location":"governance/REVIEWING/","title":"Reviewing Guide","text":"<p>This document covers who may review pull requests for this project, and guides how to perform code reviews that meet our community standards and code of conduct. All reviewers must read this document and agree to follow the project review guidelines. Reviewers who do not follow these guidelines may have their privileges revoked.</p>"},{"location":"governance/REVIEWING/#the-reviewer-role","title":"The Reviewer Role","text":"<p>Only maintainers are REQUIRED to review pull requests. Other contributors may opt to review pull requests, but any LGTM from a non-maintainer won't count towards the required number of Approved Reviews in the Mergify policy.</p>"},{"location":"governance/REVIEWING/#values","title":"Values","text":"<p>All reviewers must abide by the Code of Conduct and are also protected by it. A reviewer should not tolerate poor behavior and is encouraged to report any behavior that violates the Code of Conduct. All of our values listed above are distilled from our Code of Conduct.</p> <p>Below are concrete examples of how it applies to code review specifically:</p>"},{"location":"governance/REVIEWING/#inclusion","title":"Inclusion","text":"<p>Be welcoming and inclusive. You should proactively ensure that the author is successful. While any particular pull request may not ultimately be merged, overall we want people to have a great experience and be willing to contribute again. Answer the questions they didn't know to ask or offer concrete help when they appear stuck.</p>"},{"location":"governance/REVIEWING/#sustainability","title":"Sustainability","text":"<p>Avoid burnout by enforcing healthy boundaries. Here are some examples of how a reviewer is encouraged to act to take care of themselves:</p> <ul> <li>Authors should meet baseline expectations when submitting a pull request, such as writing tests.</li> <li>If your availability changes, you can step down from a pull request and have someone else assigned.</li> <li>If interactions with an author are not following the code of conduct, close the PR and raise it with your Code of Conduct committee or point of contact. It's not your job to coax people into behaving.</li> </ul>"},{"location":"governance/REVIEWING/#trust","title":"Trust","text":"<p>Be trustworthy. During a review, your actions both build and help maintain the trust that the community has placed in this project. Below are examples of ways that we build trust:</p> <ul> <li>Transparency - If a pull request won't be merged, clearly say why and close it. If a pull request won't be reviewed for a while, let the author know so they can set expectations and understand why it's blocked.</li> <li>Integrity - Put the project's best interests ahead of personal relationships or company affiliations when deciding if a change should be merged.</li> <li>Stability - Only merge when the change won't negatively impact project stability. It can be tempting to merge a pull request that doesn't meet our quality standards, for example when the review has been delayed, or because we are trying to deliver new features quickly, but regressions can significantly hurt trust in our project.</li> </ul>"},{"location":"governance/REVIEWING/#process","title":"Process","text":"<ul> <li>Reviewers are automatically assigned based on the CODEOWNERS file.</li> <li>Reviewers should wait for automated checks to pass before reviewing</li> <li>At least 1 approved review is required from a maintainer before a pull request can be merged</li> <li>All CI checks must pass</li> <li>If a PR is stuck for some reason it is down to the reviewer to determine the best course of action:</li> <li>PRs may be closed if they are no longer relevant</li> <li>A maintainer may choose to carry a PR forward on their own, but they should ALWAYS include the original author's commits</li> <li>A maintainer may choose to open additional PRs to help lay a foundation on which the stuck PR can be unstuck. They may either rebase the stuck PR themselves or leave this to the author</li> <li>Maintainers should not merge their pull requests without a review</li> <li>Maintainers should let the Mergify bot merge PRs and not merge PRs directly</li> <li>In times of need, i.e. to fix pressing security issues, the Maintainers may, at their discretion, merge PRs without review. They should at least add a comment to the PR explaining why they did so.</li> </ul>"},{"location":"governance/REVIEWING/#checklist","title":"Checklist","text":"<p>Below are a set of common questions that apply to all pull requests:</p> <ul> <li>[ ] Is this PR targeting the correct branch?</li> <li>[ ] Does the commit message provide an adequate description of the change?</li> <li>[ ] Does the affected code have corresponding tests?</li> <li>[ ] Are the changes documented, not just with inline documentation, but also with conceptual documentation such as an overview of a new feature, or task-based documentation like a tutorial? Consider if this change should be announced on your project blog.</li> <li>[ ] Does this introduce breaking changes that would require an announcement or bumping of the major version?</li> <li>[ ] Does this PR introduce any new dependencies?</li> </ul>"},{"location":"governance/REVIEWING/#reading-list","title":"Reading List","text":"<p>Reviewers are encouraged to read the following articles for help with common reviewer tasks:</p> <ul> <li>The Art of Closing: How to close an unfinished or rejected pull request</li> <li>Kindness and Code Reviews: Improving the Way We Give Feedback</li> <li>Code Review Guidelines for Humans: Examples of good and back feedback</li> </ul>"},{"location":"governance/SECURITY/","title":"Security Policy","text":""},{"location":"governance/SECURITY/#supported-versions","title":"Supported Versions","text":"<p>No released versions of bpfd, bpfctl, bpfd-agent or bpfd-operator will receive regular security updates until a mainline release has been performed. A reported and fixed vulnerability will be included in the next minor release, which depending on the severity of the vulnerability may be immediate.</p>"},{"location":"governance/SECURITY/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>To report a vulnerability, please use the Private Vulnerability Reporting Feature on GitHub. We will endevour to respond within 48hrs of reporting. If a vulnerability is reported but considered low priority it may be converted into an issue and handled on the public issue tracker. Should a vulnerability be considered severe we will endeavour to patch it within 48hrs of acceptance, and may ask for you to collaborate with us on a temporary private fork of the repository.</p>"}]}